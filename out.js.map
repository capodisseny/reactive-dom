{
  "version": 3,
  "sources": ["src/index.js"],
  "sourcesContent": ["\n/**\n * \n Framework to manipulate directly de the DOM using reactive programming.\n */\n\n\n const prefix = \"s-\"\n const events = {\n    // Mouse Events\n    onclick: true,\n    ondblclick: true,\n    onmousedown: true,\n    onmouseup: true,\n    onmousemove: true,\n    onmouseover: true,\n    onmouseout: true,\n    onmouseenter: true,\n    onmouseleave: true,\n    oncontextmenu: true,\n  \n    // Keyboard Events\n    onkeydown: true,\n    onkeyup: true,\n    onkeypress: true,\n  \n    // Form Events\n    onchange: true,\n    onsubmit: true,\n    onreset: true,\n    oninput: true,\n    oninvalid: true,\n    onselect: true,\n  \n    // Window Events\n    onload: true,\n    onunload: true,\n    onresize: true,\n    onscroll: true,\n    onbeforeunload: true,\n    onhashchange: true,\n    onerror: true,\n  \n    // Document Events\n    onDOMContentLoaded: true,\n    onreadystatechange: true,\n  \n    // Clipboard Events\n    oncopy: true,\n    oncut: true,\n    onpaste: true,\n  \n    // Drag and Drop Events\n    ondrag: true,\n    ondragstart: true,\n    ondragend: true,\n    ondragover: true,\n    ondragenter: true,\n    ondragleave: true,\n    ondrop: true,\n  \n    // Media Events\n    onplay: true,\n    onpause: true,\n    onended: true,\n    ontimeupdate: true,\n    onvolumechange: true,\n    onseeked: true,\n    onseeking: true,\n    ondurationchange: true,\n    oncanplay: true,\n    oncanplaythrough: true,\n  \n    // Touch Events\n    ontouchstart: true,\n    ontouchend: true,\n    ontouchmove: true,\n    ontouchcancel: true,\n  \n    // Pointer Events\n    onpointerdown: true,\n    onpointerup: true,\n    onpointermove: true,\n    onpointerover: true,\n    onpointerout: true,\n    onpointerenter: true,\n    onpointerleave: true,\n    onpointercancel: true,\n  \n    // Focus Events\n    onfocus: true,\n    onblur: true,\n    onfocusin: true,\n    onfocusout: true,\n  \n    // Device Events\n    ondeviceorientation: true,\n    ondevicemotion: true,\n  \n    // Miscellaneous Events\n    ontransitionend: true,\n    onanimationstart: true,\n    onanimationend: true,\n    onanimationiteration: true,\n    onmessage: true,\n    ononline: true,\n    onoffline: true,\n    onstorage: true,\n  };\n\n\n const directives = {\n    \n\n    bind: {\n        updateFunction(node, { oldValue, value}){\n\n            if(typeof value === \"object\"){\n    \n                Object.entries(value).forEach(([key, value]) => {\n                    \n                    node.setAttribute(key, value)\n                });\n            }\n\n        },\n\n        \n    },\n    show: {\n   \n        updateFunction:(node, { value})=>{\n\n            const args = value ? [\"\"]: [\"none\", \"important\"]\n             node.style.setProperty('display',...args);\n            // return {\n            //     style: {display: args}\n            // }\n            \n        },\n       \n    },\n\n    if:{\n\n        updateFunction(node, { value}){\n            let ref = nodeRef.commentRef = nodeRef.commentRef || document.createComment(\"if\")\n    \n            if(value){\n                \n                if(node.parentNode) return\n                ref.replaceWith(node)\n \n            }else{\n\n                node.replaceWith(ref)\n                \n            }\n        },\n       \n    },\n\n\n    //loop first to pass the apropiate data to the children\n    loop: {\n\n        //set deep to one to avoid nested updates\n        deep:1,\n        resolveExpression(expression){\n            //[m,loopKey, loopIndex,  path]\n            return expression.match(/([a-zA-Z]+)(?:\\s*,\\s*([a-zA-Z]+))?\\s+in\\s+([a-zA-Z.]+)/).slice(1)\n        },\n        getValue( ctx, expression){\n\n            const [ loopKey, loopIndex, path ] = expression\n\n            return get(ctx.data, path)\n        \n        },\n \n        createChildContext({ item,ctx, loopKey, loopIndex, key}){\n\n\n            let childData = reactive({ \n                [loopKey]:item, \n                 [loopIndex]:key,\n                }, (payload)=>{\n\n                    // debugger\n                }\n        )\n\n\n           Object.setPrototypeOf(  childData,ctx.data)\n\n                // debugger\n            let childCtx = {data:childData, isLoop:true}\n\n            return childCtx \n         \n        },\n        updateFunction(node, update, {expression, helper} , ctx){\n\n            const {type, target, key,value, updateId, oldValue} = update\n    \n            const  [ loopKey, loopIndex , path] = expression \n            const items = value\n   \n            const createFragment = (holders, oldFragment)=>{\n                const holder = document.createElement(\"div\")\n                holders.push(holder)\n                if(oldFragment) holder.append(...oldFragment.childNodes)\n                return holder\n            }\n\n\n            let template = helper.node.content\n\n            if(!node.parentNode)debugger\n\n            if(!items) return \n            \n            \n            const nodeObj = this.getNodeObject(node)  \n            const last = nodeObj.lastLoop ||[]\n             console.time(\"Comparison\")\n\n             const loop = Object.values(items)\n            const comparison = myCompare( last, loop, true)\n\n            // const comparison = minimalMovesToTransformArray(last, loop)\n            const jobs = comparison.jobs\n             console.timeEnd(\"Comparison\")\n\n             const indexMap = nodeObj.indexMap = nodeObj.indexMap || new Map()\n            const valueMap = nodeObj.indexValue = nodeObj.indexValue || new Map()\n\n             const oneJob = jobs.size === 1?[...jobs][0]:false\n\n             this.currentIsNested = this.isNested\n             this.isNested = true\n  \n             //TODO: UPDATE NODES EACH TIME to overwrite the context\n             // just update new nodes\n             // remove old nodes\n             // advantatges:\n                // no need of references and other staff like loopNodes, etc\n\n             //TODO: SELECTIVE UPDATE\n             // try to find way to add the nodes in the corresponding position\n             //cons: \n                //the unique con of this is that I need to manipulate the DOM\n                //but maybe there is no such operations where there differents indexes...\n                // the most comomn is splice which will delete and add lists of nodes so == one reflow\n\n\n             console.log(\"UPDATE LOOP\", {comparison, indexMap, items,  last, loop})\n\n            // if(jobs.size === 0) {\n            //     console.warn(\"whyyyyy\")\n            //     return\n            // }\n            const newUpdate = [] \n\n\n         \n\n\n            const groupState = {\n                indexGroup:false,\n                lastInGroup:0\n            }\n\n            comparison.remove.forEach(([index, item])=>{\n                const obj = indexMap.get(index)\n               \n        \n                nextTick(()=>{\n                    \n                    obj.nodes.forEach(node=>node.remove())\n                    //ensure add actions also do this async\n                    indexMap.delete(index)\n                   \n                })\n\n            })\n\n\n\n            //items that are not moved manually moved becaause are pushed up the array\n            comparison.updated.forEach(( [from,  to, item])=>{\n\n                const obj = indexMap.get(from)\n\n                // debugger\n                 obj.ctx.data[loopIndex] = to\n\n                 nextTick(()=>{\n                     indexMap.set(to, obj)\n                    // obj.ctx.data[loopIndex] = index\n                 })\n          \n            })\n\n            //items that especified to be moved\n            const entireMove = comparison.move.length == items.length\n         \n            comparison.move.forEach(( [fromIndex,toIndex])=>{\n\n    \n                const obj = indexMap.get(fromIndex)\n                const toObj = indexMap.get(toIndex)\n                // debugger\n\n                 //add reference\n                 const fromRef = new Text(\"\")\n                 obj.ref = fromRef\n                 obj.nodes[0].before(fromRef)\n       \n                //place nodes\n                 const ref = toObj.ref || toObj.nodes[0]\n                \n                 const newNode = document.createDocumentFragment()\n                 newNode.append(...obj.nodes)\n\n\n                 //index is not update\n                //  this.addToUpdate(newNode, fromIndex, newUpdate, groupState , indexMap, node)\n                 ref.before(...obj.nodes)\n                //  if(entireMove){\n                //  }else{\n                //     ref.before(...obj.nodes)\n                //  }\n             \n\n                 obj.ctx.data[loopIndex] = toIndex\n\n\n                 nextTick(()=>{\n                     indexMap.set(toIndex, obj)\n\n                     obj.ref.remove()\n                    delete obj.ref\n                 })\n          \n            })\n\n            \n            comparison.add.forEach(([index, item])=>{\n                index = parseInt(index) // ensure integers\n\n                if(typeof index === \"string\") {\n\n                   throw new Error(\"Index must be a number\")\n                }\n\n                   //create a new context\n                   const childCtx = this.createChildContext({path, item,ctx, loopKey, loopIndex, key:index})\n\n                   //create a node\n                   const newNode =  template.cloneNode(true)\n                   //   registerNodeUpdate(child, childCtx)\n                   template.childNodes.forEach((child, i)=>{\n                        parallelUpdate(child, newNode.childNodes[i], childCtx)\n                    })\n                  \n                   this.addToUpdate(newNode, index, newUpdate, groupState , indexMap, node)\n                   \n\n\n                   const obj =  {\n                       nodes:[...newNode.childNodes], \n                       ctx:childCtx,\n                       item,\n                    //    index\n                   }\n\n                //    valueMap.set(item, obj)\n                  nextTick(()=>{\n                    indexMap.set(index, obj)\n                  })\n            })\n\n\n\n            // newUpdate.forEach((group, index)=>{\n\n\n                \n            //    debugger \n            // })\n\n            \n            if(!this.currentIsNested){\n                \n                this.updateLoop( newUpdate)\n\n                nextTick(()=> this.isNested = false)\n\n            }else{\n                // debugger\n    \n                this.updateLoop(newUpdate)\n                \n            }\n    \n        \n            nodeObj.lastLoop  = loop\n            \n        },\n        addToUpdate(newNode, index, newUpdate, groupState , indexMap, node){\n            let { indexGroup, lastInGroup} = groupState\n              //create a group index\n              if( indexGroup === false || index > (lastInGroup + 1) ){\n                indexGroup = groupState.indexGroup = index \n                newUpdate[indexGroup] = newUpdate[indexGroup] || {nodes:[]}\n            \n            }\n\n            const group = newUpdate[indexGroup] \n            //add rerefence where to attach new group\n            if(!group.ref){\n\n                //index group found or node\n                const obj = indexMap.get(index)\n    \n                group.ref = obj?.ref || obj?.nodes[0] ||\u00A0node\n            }\n\n            groupState.lastInGroup = index\n\n             group.nodes.push(newNode)\n        },\n        updateLoop( newUpdate){\n\n        \n            newUpdate.forEach((group, index)=>{\n                const {nodes, ref} = group\n      \n                ref.before(...nodes)\n            }) \n\n\n  \n        }\n        \n\n    }\n    \n    \n}\n \n\nwindow.createContext = createContext\nwindow.reactive = reactive\nwindow.watch = watch\nwindow.nextTick = nextTick\n\nfunction createContext(data, root){\n\n  \n     root = root || getPrevious() ||\u00A0document.body\n\n \n\n    if(typeof data === \"string\") {\n        data = reactive({})\n    }\n        \n    const ctx =   {\n        data,\n        root,\n    }\n\n    console.time(\"Compilation\")\n    //  let compiled = compileNodes(root,  ctx )\n     let compiled = compileHelpers(root )\n\n     console.timeEnd(\"Compilation\")\n\n     console.log(\"compiled\", compiled)\n\n\n      runUpdates(ctx)\n    //  initializeNodes(ctx)\n     \n     return {}\n}\n\n\n\nconst proxies = {\n    reactive: new WeakMap()\n}\n\nconst isProxyFlag = Symbol('__isProxy');\n\nfunction isReactive(obj){\n    if(!obj) return false\n    // if(typeof obj !== \"object\") return false\n    // console.log(obj)\n    //  return obj.__raw ? true: false\n     return obj?.__isReactive\n\n}\nconst interceptors = {\n\n    //chat gpt solution for check proxies with prototypes\n    //IMPORTANT: do not delete this\n     // Intercept and return `false` for the `hasOwnProperty` check on the flag\n    //  hasOwnProperty:{\n    //     get(target, key, value, receiver){\n\n    //         if (prop === 'hasOwnProperty') {\n    //             return (key) => key !== isProxyFlag;\n    //           }\n    //           return Reflect.get(target, key, receiver);\n    //     }\n    //  },\n     \n      \n    //   [isProxyFlag]:{\n    //         get(target, key){\n    //               // Intercept access to the symbol-based flag\n    //             if (prop === isProxyFlag) {\n    //                 return true;  // Indicate that this object is proxied\n    //             }\n    //             return Reflect.get(target, key, receiver);\n    //         }\n    //   },\n\n    __isReactive:{\n\n        get(target, key, value, reciever){\n            \n    \n            return this.proxy == reciever\n\n            return reciever == this.target\n        },\n\n    },\n    __raw:{\n        get(target){\n            // console.log(\"the targettt\", target)\n            return target\n            return this.target\n        }\n    },\n    __parent:{\n        set(target, k, v){\n\n            return this.parent = v\n        }\n    },\n    __key:{\n        set(target, k, v){\n            return this.key = v\n        }\n    }\n    \n  \n }\n \n\n\nfunction reactive(obj, callbacks = [],  parent,key,  origin){\n\n    if(typeof obj !== \"object\") return obj\n    if(!obj)return  \n\n    if(isReactive(obj)) {\n       \n        obj.__parent  = parent\n        obj.__key = key\n\n         return obj\n \n     }\n \n\n    let current =  proxies.reactive.get(obj)\n\n    if(current ) {\n            return current\n    }\n\n    let handler =   new ReactiveHandler({target:obj, parent,key, origin:origin ||\u00A0obj,callbacks })\n    let proxy =  new Proxy(obj, handler)\n\n    handler.proxy = proxy\n    proxies.reactive.set(obj,proxy)\n\n        return proxy\n } \n\n\n  const effectStack = []\n class ReactiveHandler{\n\n    static handlers = []\n    \n    static queue = []\n    static handlersByObject = new WeakMap()\n    constructor(options = {}){\n\n        this.effects = new Set()\n\n        this.constructor.handlers.push(this)\n\n        this.origin = options.origin\n        this.target = options.target\n\n        this.queue = []\n\n        //instead of an array of parents just pass the \n        this.parent = options.parent\n        this.key = options.key\n\n        this.deepEffects  = new Set()\n\n        \n        if(options.callbacks){\n            this.addDeepEffect(options.callbacks)\n        }\n\n        if(typeof this.target != \"object\")debugger\n    \n        this.constructor.handlersByObject.set(this.target, this)\n    }\n  \n    //use the handler to run the logic, since the handler has control on the time and data to update\n    runEffect(effect, depth , payload){\n\n        if(effect.ran) return\n        nextTick(()=> effect.ran = false)//setTimeout(()=> effect.ran = false)\n\n        \n        const isFunction = typeof effect == \"function\" \n        const deep = isFunction?true:effect.deep\n        if(depth && deep){\n     \n            //check depth\n            if( deep !== true && depth > deep)  return\n\n            this.runNextUpdate(effect, depth, false, payload)            \n\n        }\n        //without depth only run the obersving props\n        if(!depth){\n\n            const observingProps = effect.observing.get( this)\n\n            this.runNextUpdate(effect, 0, observingProps, payload)\n\n        }\n  \n\n       \n    }\n\n    runDeep(){\n\n            //generate an inverted deep   // src/explanations.txt #invertedDeep\n            let deep = 1\n            let current = this\n            const parents = []\n    \n            // let path = []\n            let path = false\n            while(current){\n\n                if(current.key){\n                    // path.unshift(current.key)\n                    if(!path ) path = current.key\n                    else path = `${current.key}.${path}`\n                }\n                \n                parents.push([current, deep, path])\n                current = current.parent\n                deep++\n            }\n\n            //run first main parent effect\n            parents.reverse()\n    \n            parents.forEach(([handler, depth, path])=>{\n\n                const payload = {path, sourceTarget:handler.target}\n                \n                handler.deepEffects.forEach(effect=>{\n\n                    this.runEffect(effect, depth, payload)\n              \n                })\n            })\n    }\n\n    runNextUpdate(effect, depth,observingProps , payload ){\n\n     \n        if(!observingProps){\n            observingProps = this.nextUpdate\n        }\n \n        \n        Object.keys(observingProps).forEach((key)=>{\n\n            if(!observingProps[key])return \n            if(!this.nextUpdate.hasOwnProperty(key)) return \n\n            // const payload = depth?this.target: this.nextUpdate[key]\n            if(!payload) payload = this.nextUpdate[key]\n            else Object.assign(payload, this.nextUpdate[key])\n\n            if(typeof effect == \"function\"){\n                effect(payload, this)\n                return \n            }\n            effect.runWithPayload(payload, this)\n        })\n\n\n    }\n\n    addDeepEffect(deepEffect){\n        \n\n        const deepEffects = this.deepEffects\n        if(typeof deepEffect  == \"function\" || deepEffect instanceof Effect){\n        \n            // if(deepEffect.toString().includes(\"update child\")) debugger\n            deepEffects.add(deepEffect)\n\n        }\n        else if(Array.isArray(deepEffect) ){\n            deepEffects.forEach(effect=>{\n                this.addDeepEffect(effect)\n            })\n           \n        }\n        else{\n            console.warn(\"deepEffects must be an array, a function or an Effect\")\n        }\n    }\n\n    static get currentEffect(){\n        return effectStack.at(-1)\n     }\n     static set currentEffect(v){\n         if(v){\n             effectStack.push(v)\n         }else{\n             effectStack.pop()\n         }\n         return true\n      }\n\n    static getHandler(obj){\n\n       return  this.handlersByObject.get(toRaw(obj))\n    }\n\n    addEffect(effect, key, target){\n\n  \n        if(!this.effects.has(effect)) this.effects.add(effect )\n\n        //ad property to the list of observing propertis of the effect\n        effect.observeProp(this, key)\n      \n\n    }\n    \n    get(target, key, reciever){\n\n         let value = target[key]\n        // let value = Reflect.get(target, key)\n\n        if(interceptors[key]?.[\"get\"]){\n            return interceptors[key][\"get\"].call(this,target, key, value, reciever )\n        }\n\n\n\n        //trigger get\n        const currentEffect = this.constructor.currentEffect\n\n\n        // if(Array.isArray(target) && target.length == 3) debugger\n        if( currentEffect){\n\n            // if(key == \"i\") debugger\n                // if(key == \"style\" &&  this.origin.attrs)debugger\n             this.addEffect(currentEffect, key)\n            // this.addDeepEffect(currentEffect)\n\n        }   \n\n    \n        if(typeof value === \"object\"){\n            return reactive(value, false, this ,key, this.origin,  )\n        }\n\n   \n\n       \n        if(Array.isArray(target) ){\n\n            // return handleArrayFunctions(key, target, value, this)\n\n        }\n\n        \n        return value\n    }\n\n    \n      \n\n\n    // apply(target, thisArg, args){\n\n    // }\n    set(target, key, value, reciever){\n\n  \n        if(interceptors[key]?.[\"set\"]){\n            return interceptors[key][\"set\"].call(this,target, key, value, reciever,  )\n        }\n\n\n        const oldValue = target[key]\n\n        // Reflect.set(target, key, value)\n         target[key] = value\n\n        //has no much difference on performance\n        //but it creates so many updates, is better just to send the updat eon the length\n        //but with mutations like reverse, sort, etc, I need to send the update\n        //just check if is queued\n        if(Array.isArray(target) && this.nextUpdate) {\n\n            return true\n        }\n\n        this.queueMutation({type:\"set\", target, key, value, oldValue, origin:this.origin})\n        \n        return true\n    }\n    deleteProperty(target, key) {\n        if (key in target) {\n\n                    \n            const oldValue = target[key]\n            let oldKey \n            if(Array.isArray(target)){\n              oldKey = target.indexOf(oldValue)\n            }\n\n          delete target[key];\n\n         if(Array.isArray(target) && this.nextUpdate) {\n\n            return true\n        }\n          this.queueMutation( {type: \"delete\",value:target[key],oldKey, target, key,oldValue,  origin:this.origin} )\n\n          return true\n          // Expected output: \"property removed: texture\"\n        }\n      }      \n\n    triggerUpdate(){\n\n        // TODO: I think that I can merge all this in to the same funtions, \n        // I don't need deepEffects and effects, just one Set of effects\n\n        //run deep effects\n        this.runDeep()\n\n       //handle own effects\n        this.effects.forEach(effect=>{\n\n\n            this.runEffect(effect)\n\n            // effect.updateWithHandler(this)\n           \n            \n        })\n       \n        this.nextUpdate = false\n    }\n\n    static runUpdates(){\n\n        // console.log(\":::::RRRRunning update\")\n        // this.queue.forEach((reactiveHandler )=> {\n        //     reactiveHandler.triggerUpdate()\n        // })\n        // this.queue.length = 0\n\n\n        while(this.queue.length) {\n            const reactiveHandler =  this.queue.shift()\n            reactiveHandler.triggerUpdate()\n        }\n \n        this.updating = false\n\n         Manager.runNextTick()\n    }\n\n    \n\n    queueMutation(payload){\n\n        //push mutation to the queue\n        ReactiveHandler.queue.includes(this) ||\u00A0 ReactiveHandler.queue.push(this)\n\n\n        //prepare set properties changes in this object\n        this.nextUpdate = this.nextUpdate || {}\n        //  new Proxy({}, {set(t,k,v){\n        //     if(k == \"more\") debugger\n        //     return t[k] = v\n        // }})\n\n\n        // if(Array.isArray(payload.target))debugger\n        //save payload in an object, so last value update is triggered only\n        this.nextUpdate[payload.key] = payload\n\n        if(!ReactiveHandler.updating){\n            ReactiveHandler.updating = true\n        \n            console.time(\"Collect updates\")\n            // console.trace();\n\n            // ReactiveHandler.runUpdate()\n            // (async ()=>{\n\n            //     ReactiveHandler.runUpdate()\n            // })(window)\n            //  requestAnimationFrame(()=>{\n            //     // console.log(\"tringgering update\")\n            //     console.timeEnd(\"Collect updates\")\n              \n            //     ReactiveHandler.runUpdates()\n            //   })\n\n            //Like this looks better, \n            //request animation frame can go on the loop, so first will happen the updates\n            //and then at requestAnimationFrame, will be appended.\n              Promise.resolve().then(()=>{\n\n\n                console.log(\"tringgering update\")\n                console.timeEnd(\"Collect updates\")\n              \n                ReactiveHandler.runUpdates()\n              })\n         \n        }else{\n\n            // console.warn(\"is this mutation registering\", payload)\n\n            // debugger\n        }\n    }\n\n\n }\n\n\n function compute(computation){\n\n\n    let val \n\n    effect((payload)=>{\n\n        val = computation(payload)\n    })\n\n    return val\n\n\n\n }\n\n function effect(callback, options){\n\n    options = {\n        ...(options||{})\n    }\n     return new Effect(callback, options)\n\n }\n\n\n\n class Effect{\n\n    onTrigger = false\n    handler = false\n    immediate = true\n    deep = false\n\n    static eventTarget = new EventTarget()\n    static observingTarget = new WeakMap()\n\n    static setTargetObserver(effect, target){\n\n        target = toRaw(target)\n\n       let handler =  ReactiveHandler.getHandler(target)\n\n       if(handler){\n\n            if(typeof effect == \"function\")debugger\n            handler.addDeepEffect(effect)\n            \n       }else{\n\n        console.warn(\"no handler found\", target)\n       }\n      \n  \n    }\n    constructor(source, options){\n\n        const props = [\"immediate\", \"callback\",  \"onTrigger\", \"deep\", \"updater\"]\n\n        this.source = source\n\n        if(typeof source == \"object\"){\n            \n            this.deep = 1\n            Effect.setTargetObserver(this, source)\n        }\n\n        props.forEach(prop=>{\n            if(options.hasOwnProperty(prop)) this[prop] = options[prop]\n        })\n\n        //[handler] - {[key]:true} observing\n        this.observing = new WeakMap()\n\n        //initiliaze the effect\n        let value = this.run()\n\n\n        //run callback\n        if(this.immediate && this.callback){\n\n            this.callback.call(undefined, {value})\n        }\n\n        this.nextUpdate = {}\n\n    }\n\n    run(payload = {}, handler){\n\n         //the effect can run on multiple payload, since updats are collected \n        const source = this.source\n\n        let value \n\n        ReactiveHandler.currentEffect = this\n\n        if(typeof source == \"function\") value = source(payload, handler)\n\n        this.lastValue = value\n         \n        //observe result object\n       if(this.deep && isReactive(value)){\n    \n            Effect.setTargetObserver(this, value)\n       }\n\n       ReactiveHandler.currentEffect = false\n\n\n    }\n\n    runWithPayload(payload, handler){\n\n        this.run(payload, handler )\n\n       if(  this.callback ){\n            this.callback.call(undefined, payload)\n        }\n\n    }\n   \n    observeProp(reactiveHandler, prop){\n\n        let observing = this.observing.get(reactiveHandler) \n        if(!observing) {\n            observing = {}\n            this.observing.set(reactiveHandler, observing)\n        }\n\n        observing[prop] = true\n    }\n }\n\n\n\n\n function watch(source, callback, runOrOption ){\n\n    const run = typeof runOrOption === \"boolean\" ? runOrOption : false\n   \n    \n    const options = {\n        callback, immediate: run,\n        ...(runOrOption ||{})\n    }\n    let t = typeof source \n\n\n    if(t !== \"object\" && t !== \"function\"){\n\n        console.warn(\"watch source must be an object or a function\")\n        return\n    } \n    \n\n   return effect(source, options)\n    \n    \n }\n\n\n\n\n\n    function set(obj, path, value){\n            \n        if(!path?.split)debugger\n            let keys = path.split(\".\")\n\n            let target = obj\n            let lastKey = keys.pop()\n    \n            for(let key of keys){\n                if(!target) return \n                target = target[key]\n            }\n    \n            target[lastKey] = value\n\n    }\n\n\n    class Manager{\n        static isRendering = false\n        static runNextTick(){\n\n            if(this.isRendering ) {\n                //  setTimeout(()=>this.runNextTick(), 0)\n              \n                // requestAnimationFrame(()=>{\n                //     this.runNextTick()\n                // })\n                 return\n            } \n            this.isRendering = true;\n\n\n            //  const queue = [...Manager.nextTickQueue]\n            //  //reset queue\n            //  Manager.nextTickQueue.length = 0\n             const queue = Manager.nextTickQueue\n             // Execute all the queued callbacks\n             //this makes inputs be able to focus on the nextTick\n             //this doesn't affect the real time of renderization\n             setTimeout(()=>{\n                while ( queue.length) {\n                    const callback = queue.shift();\n                    if(!callback?.call){\n                        \n                        continue;\n                    }\n                    callback();  // Run the callback\n                }\n                 // Mark rendering as done, so further nextTicks can be scheduled\n                 this.isRendering = false;\n              })\n\n        }\n       \n\n       static nextTickQueue = []\n    }\n\n\n    function nextTick(callback){\n            \n\n        Manager.nextTickQueue.push(callback)\n\n        if(Manager.isRendering){\n        //    setTimeout( ()=>Manager.runNextTick(), 0)\n        }\n\n    }\n\n\n\n    const getCache = new Map()\n\n    Manager.getCache = getCache\n    \n    function get(obj, path){\n\n        // let cache = getCache.get(obj) \n        \n        // if(cache && cache[path]){\n        //     return cache[path]\n        // }\n        if(!path?.split)debugger\n\n        const keys = path.split(\".\")\n        let target = obj\n\n        let val\n        for(let key of keys){\n            if(!target) {\n                val = undefined\n                break;\n            } \n            target = target[key]\n        }\n\n        val = target\n        \n        // if(!cache){\n        //     cache = {}\n           \n        //     //   getCache.set(obj, {[path]:val})\n        // }\n        // cache[path] = val\n\n        return val\n\n    }\n\n\n\n      function getPrevious(){\n        // Select the script element\n        const currentScript = document.currentScript;\n        // Get the previous sibling element\n\n        return currentScript.previousElementSibling;\n\n\n      }\n\n      \n\n/**\n * \n  Compile the nodes of the root element into an referenced object\n\n{\n  node: <Node>,\n  textContent: <String>,\n    attrs: {\n        <attrName>: <attrValue>,\n        ...\n    },\n    events: {\n        <eventName>: <eventHandler>,\n        ...\n    }\n  }\n */\n\n\nclass CompiledRef {\n    constructor(){\n\n        this.map = new Map()\n        this.idMap = new Map()\n    }\n    get(v){\n        // if(!v?.__sId) debugger\n        if(v?.__sId){\n            \n          return this.idMap.get(v.__sId)\n        }\n        let attr = v?.getAttribute?v.getAttribute(\"__sId\"):false\n        if(attr){\n            return this.idMap.get(attr)\n        }\n       return  this.map.get(v)\n    }\n    set(k, ref){\n         this.map.set(k, ref)\n\n       return  this.idMap.set(ref.id, ref)\n    }\n    has(v){\n        return this.map.has(v)\n    }\n    getByDepth(id){\n\n        return this.idMap.get(id)\n\n    }\n}\nconst compiledRefs = new CompiledRef()\nconst updateNodesQueue = new WeakMap()\n\nlet idCounter = 0;\n\nconst nodeUpdateQueue = []\nfunction registerNodeUpdate(template, node, ctx){\n\n    nodeUpdateQueue.push([template, node, ctx])\n\n}\n\nlet runningQueue = false\nfunction updateQueue(ctx){\n    \n        if(runningQueue)return \n        runningQueue = true\n       \n        // console.log(\"running queue\")\n        // nodeUpdateQueue.reverse()\n        while(nodeUpdateQueue.length){\n            const [node, cloneOrCtx, childCtx] = nodeUpdateQueue.pop()\n      \n            if(childCtx){\n                \n                debugger\n                parallelUpdate(node, cloneOrCtx, childCtx)\n            }else{\n\n\n                if(ctx){\n                    compiledRefs.get(node).runNodeUpdates(node, childCtx || ctx)\n                }else{\n                    updateNode(node, cloneOrCtx)\n                }\n\n                // updateNode(node, cloneOrCtx)\n\n                // compiledRefs.get(node).runNodeUpdates(node, childCtx || ctx)\n\n            }\n        }\n\n        runningQueue = false\n        // nodeUpdateQueue.length = 0\n}\nfunction compileHelper(node, isTemplate){\n\n       \n        if( node.__sCompiled ) return compiledRefs.get(node)\n         //save compiled prop for faster access\n\n        //set the id \n        if(node.dataset) {\n            // node.dataset.__sId = nodeRef.id\n            // node.setAttribute(\"__sId\", nodeRef.id)\n        }\n\n       \n        if(node.tagName !== \"TEMPLATE\") node.__inTemplate = isTemplate\n\n        //compile text nodes\n        if ( node.nodeType == node.TEXT_NODE && node.textContent.includes(\"{{\") ) {\n         \n            setNode = true\n    \n            let children = fastParse( node.textContent)\n            \n            children = children.map(child=>{\n                if(child.path){\n                              \n                    const node = document.createTextNode(`{{${child.path}}}`)\n                    node.__inTemplate = isTemplate\n                    \n                    const helper =  new NodeHelper(node )\n                    helper.addUpdate(\"text\", child.path)\n\n                    return node\n                }\n\n                const node = document.createTextNode(child)\n                node.__inTemplate = isTemplate\n\n                return node\n                \n            })\n\n\n             node.replaceWith(...children)\n                \n        }\n    \n        //compile other nodes\n        if(node.attributes?.length){\n           \n            let helper \n                \n            const attrs = node.attributes; // Get all attributes of the element\n            Object.values(attrs).forEach((attr) => {\n                let value = attr.value;\n                let key = attr.name\n    \n                //DIRECTIVES\n                if(key.startsWith(prefix)){\n\n                        helper = helper || new NodeHelper(node )\n                    \n                    let directiveKey = key.slice(2)\n                    if(directives[directiveKey]){\n                        \n                        setNode = true\n\n                        helper.addUpdate(directiveKey, value.slice(2, -2))\n                        \n                        node.removeAttribute(key)\n                    }\n                    return \n                }\n\n\n\n                //EVENTS\n                if(events[key]){\n                    helper = helper || new NodeHelper(node )\n                    \n\n                    helper.addUpdate(\"events\", value, {key:key.slice(2) })\n                    \n                    node.removeAttribute(key)\n                    return \n                }\n\n\n                //ATTRIBUTES\n                if(value.includes(\"{{\")){\n                    helper = helper || new NodeHelper(node )\n\n                    helper.addUpdate(\"attrs\",value.trim().slice(2, -2),  { key})\n                \n           \n                }\n                \n            })\n        }\n\n\n        if(node.tagName == \"TEMPLATE\"){\n\n            // const templateRef = document.createElement(\"reactive-template\")\n            const templateRef = document.createComment(\"template\")\n       \n            templateRef.__inTemplate = isTemplate\n            const ref = compiledRefs.get(node)\n            node.replaceWith(templateRef)\n            templateRef.__sId = ref.id\n\n            templateRef.id= ref.id\n\n            registerNodeUpdate(templateRef)\n\n            ref.root = templateRef\n\n\n            // templateRef.setAttribute(\"id\", ref.id)\n    \n             document.body.append(node)\n           \n        }\n\n        return {}\n    \n}\n\nfunction compileHelpers(root){\n\n    let isTemplate = false\n    fastTraverseDOM(root, (node)=>{\n      \n\n        if(node.parentNode?.nodeType === 11 || node.textContent ==\"template\" ) isTemplate = node.parentNode\n        if(node.previousSibling?.tagName == \"TEMPLATE\" || node.previousSibling?.textContent ==\"template\") isTemplate = false\n   \n        compileHelper(node , isTemplate) \n        \n    })\n\n\n    return compiledRefs\n\n\n}\n\n\n\n\n      /**\n       * \n       *\n       * Update order from chatgpt\n       \n        Style Updates: Apply layout-affecting styles first (e.g., width, height, display).\n        Class Updates: Modify classes next (especially if they affect styles or layout).\n        Child Modifications: Add, remove, or reorder child nodes.\n        Text Content Updates: Update the text content or innerHTML (after structural changes).\n        Other Attributes: Modify attributes that don\u2019t affect layout (e.g., data-*, aria-*).\n        Event Listeners: Add event listeners last, after the DOM is fully updated.\n       */\n        function runUpdates(ctx){\n        \n\n            let {show, text, loop,attrs } =  NodeUpdater.updaters\n       \n\n             updateQueue(ctx)\n       \n             \n           }\n\n\n\n           //generates a stack like  stack = [child1, child2, child3, parent]\n\nfunction fastTraverseDOM(root, processNode) {\n\n\n    const stack = [root];\n    \n\n    while (stack.length > 0) {\n\n        let  node = stack.pop();\n    \n       \n        //is is an element instead of a template\n        if( node.hasAttribute && node.hasAttribute(\"s-loop\") && node.tagName !== \"TEMPLATE\"){\n            // let ref =  document.createTextNode(\"\")\n            const newTemplate = document.createElement(\"template\")\n            // let newTemplate = document.createDocumentFragment()\n\n            newTemplate.setAttribute(\"s-loop\", node.getAttribute(\"s-loop\"))\n\n    \n            //remove s-llop to avoid inifinite loop\n            node.removeAttribute(\"s-loop\")\n            node.after(newTemplate)\n            newTemplate.content.appendChild(node)\n\n\n            node = newTemplate\n\n\n\n        }\n\n\n         //also process template children\n         const childNodes = (node.tagName == \"TEMPLATE\" )? node.content.childNodes:node.childNodes\n\n\n        //set a node id\n         processNode(node );\n\n       \n        // Push child nodes to the stack in reverse order\n        // This ensures we process them in the correct order when popping       \n        for (let i = childNodes.length - 1; i >= 0; i--) {\n\n             stack.push(childNodes[i]);\n        }\n\n\n    \n\n    }\n\n  \n\n}\n\n\n\n\n//converts a string text that contain \"{{some}}\" into multiple text nodes\nfunction fastParse(str) {\n    let result = [];\n    let start = 0;\n    let openBrace = str.indexOf('{{');\n    \n    while (openBrace !== -1) {\n        if (start !== openBrace) {\n            const noExpression= str.slice(start, openBrace)\n            // result.push(document.createTextNode(noExpression));\n            result.push(noExpression);\n        }\n        \n        let closeBrace = str.indexOf('}}', openBrace);\n        if (closeBrace === -1) break;\n        \n        let path = str.slice(openBrace + 2, closeBrace).trim();\n         result.push({path});\n        // result.push(document.createTextNode(path))\n        start = closeBrace + 2;\n        openBrace = str.indexOf('{{', start);\n    }\n    \n    if (start < str.length) {\n        const noExpression= str.slice(start)\n        result.push(noExpression)\n        // result.push(document.createTextNode(noExpression));\n    }\n    \n    return result;\n}\n\n\n\n\n\n\n\nfunction createComponent(template){\n\n\n  customElements.define(\n    \"reactive-template\",\n    class extends HTMLElement {\n    static observedAttributes = [\"id\"];\n      constructor() {\n        super();\n\n        debugger\n        // let template = document.getElementById(\"custom-paragraph\");\n        // let templateContent = template.content;\n  \n        // const shadowRoot = this.attachShadow({ mode: \"open\" });\n        // shadowRoot.appendChild(templateContent.cloneNode(true));\n      }\n      attributeChangedCallback(name, oldValue, newValue) {\n        console.log(`Attribute ${name} has changed.`);\n        if(name == \"id\"){\n            let ref = compiledRefs.idMap.get(newValue)\n            if(!ref) debugger\n            let template = ref.node \n\n            \n            // const shadowRoot = this.attachShadow({ mode: \"open\" });\n            // shadowRoot.appendChild(templateContent.cloneNode(true));\n         \n            this.replaceWith(template.content.cloneNode(true))\n        }\n      }\n    },\n  );\n\n\n\n  }\n\n\n\n  function updateNode(root, ctx){\n\n\n    if(!Array.isArray(root)) root = [root]\n    const stack = [...root]\n\n    while(stack.length){\n        const node = stack.pop()\n        const ref = compiledRefs.get(node)\n\n        if(ref){\n\n\n             ref.runNodeUpdates(node, ctx, true)\n        }\n        // const childNodes = (node.tagName == \"TEMPLATE\" )? node.content.childNodes:node.childNodes\n        const childNodes = node.childNodes\n\n        for(let i = childNodes?.length - 1; i >= 0; i--){\n           \n            stack.push(childNodes[i])\n           \n        }\n    }\n  }\n\nfunction parallelTraverse(root, clone, callback){\n\n    let stack = [[root, clone]]\n    while(stack.length){\n        let [node, clone] = stack.pop()\n\n        if(!clone?.childNodes)debugger\n        let children = node.childNodes\n        let cloneChildren = clone.childNodes\n\n        callback(node, clone)\n\n        for(let i = children.length - 1; i >= 0; i--){\n            stack.push([children[i], cloneChildren[i]])\n        }\n    }\n\n}\n\nfunction  cloneDeep(template, callback, ){ \n\n\n    const stack = [[template]]\n    let root \n   while(stack.length){\n        let [node,parent, ] = stack.pop()\n\n        if(!node)debugger\n        const isTemplate = node.tagName == \"TEMPLATE\" \n\n        //do not clone templates\n        const newNode = isTemplate?node: node.cloneNode()\n        const ref = compiledRefs.get(node)\n\n        if(ref) newNode.__sId = ref.id\n\n        if(!root) {\n            root = newNode\n           \n        }\n        \n        if( parent && !parent.__inTemplate && !isTemplate) {\n            parent.appendChild(newNode)\n        }\n       \n     \n        //IF IS A TEMPLATE, PASS the parent of the template as a parent\n        const nodeParent = node.tagName == \"TEMPLATE\"?newNode.parentNode:newNode\n        //get child nodes of the fragment\n        const childNodes = (node.tagName == \"TEMPLATE\" )? node.content.childNodes:node.childNodes\n\n        if(callback) callback(newNode, ref, )\n\n        if(node.textContent == \"template\") {\n            debugger\n            continue\n        }\n        if(isTemplate){\n            debugger\n        };\n    \n\n        for(let i = childNodes?.length - 1; i >= 0; i--){\n                       \n            stack.push([childNodes[i], nodeParent])\n           \n        }\n    }\n\n    return root\n\n}\n\n\n\n      class NodeHelper{\n\n        // directives = false\n        // attrs = false\n        // events = false\n        // textContent = false\n\n        node = false\n\n        constructor(node, updaters = {}){\n\n            this.id = `id-${idCounter++}`\n         \n            this.node = node\n            this.updates = new Set();\n\n            if(node.inTemplate) this.inTemplate = true\n            else if(node.tagName !== \"TEMPLATE\") {\n\n                registerNodeUpdate(node)\n            }\n\n            compiledRefs.set(node, this)\n            node.__sCompiled \n\n        }\n        addUpdate(id, expression, config){\n\n            let updater = NodeUpdater.getInstance(id)\n\n            if(!updater){\n                console.warn(`Updater ${id} not found`)\n                return\n            }\n    \n            const update =  new NodeUpdate(updater, expression, config)\n\n            update.helper = this\n\n            this.updates.add(update)\n\n        }\n        runNodeUpdates(node, ctx, force){\n    \n            if(!node.__sId) node.__sId = this.id\n            this.updates.forEach(update=>{\n               \n                if(force){\n                    update.forceUpdate(node ,ctx )\n                }else{\n                   \n                    update.setupNode(node, ctx)\n\n                }\n            })\n\n        }\n    \n      }\n\n      /**\n       * IMPORTANT:\n       * \n       Summary of Optimal Update Order:\n        Styles (especially layout-affecting styles like width, height, margin)\n        Classes (if they affect styles or layout)\n        Text Content (textContent or innerHTML)\n        Other Attributes (e.g., data-*, aria-*, non-layout attributes)\n       */\n\n    class NodeUpdater{\n        static updaters = {}\n        priority = 10\n \n        constructor(options){\n            this.constructor.updaters[options.id] = this\n\n            this.updateFunction = options.updateFunction\n\n            // let validOptions = [\"getValue\", \"resolveExpression\", \"effect\", \"type\", \"priority\", \"id\"]\n            Object.keys(options).forEach(key => {\n                // if(!validOptions.includes(key)) return\n                      this[key] = options[key]\n \n            });\n        }\n\n        static getInstance(id){\n           return  this.updaters[id] \n        }\n           \n        updateFunction(){\n\n            console.warn(\"Update function not created for this nodeUpdater\")\n            \n        }\n        \n        nodes = new WeakMap()\n    \n        getNodeObject(node){\n            if(this.nodes.has(node)){\n                return this.nodes.get(node)\n            }\n            const obj = { expressions:{}}\n            this.nodes.set(node, obj)\n            return obj\n        }\n        \n\n        getPropertyTarget(obj, prop){\n\n            while(!obj.hasOwnProperty(prop)){\n                \n               if( obj.hasOwnProperty(prop)) return obj\n               let proto = Object.getPrototypeOf(obj)\n               if(proto) obj = proto\n               else return obj\n            }\n            return obj\n        }\n\n        resolveExpression(expression){\n\n            expression = expression.trim()\n\n            if(expression.startsWith(\"(\")){\n\n                return new Function(\"return \" + expression)\n            }\n\n            return expression\n        }\n        \n\n      }\n\n\n\n\n  class Context {\n   \n    \n    constructor(ctx ){\n    \n\n\n    }\n\n}\n\n\n\n\nclass NodeUpdate {\n    constructor( updater, rawExpression, config ){\n    \n       \n        this.ctxs = new Set()\n        this.ctxNodes = new WeakMap()\n        this.updater = updater\n\n        const[exp, debug] = rawExpression.split(\":\")\n\n        this.debug = debug\n        this.raw = exp   \n       \n        if(config) this.config = config\n\n        this.expression = updater.resolveExpression(exp)\n\n    }\n\n    forceUpdate(node, ctx){\n\n        //no rerun update on ones without effect\n        if(this.updater.effect === false) return\n\n\n        if(node.__inTemplate) {                    \n           return;\n        }\n        const updater = this.updater\n                 \n       const value = this.getValue(ctx)\n                        \n       if(!updater.updateFunction)debugger\n       \n        updater.updateFunction(node, { value} ,this, ctx)\n\n\n    }\n\n    getValue(ctx){\n\n       \n        if( this.updater.getValue) return this.updater.getValue(ctx, this.expression)\n\n\n        if(typeof this.expression == \"function\"){\n\n            return this.expression.call(ctx.data)\n        }\n\n\n        return get(ctx.data, this.expression)\n       \n     \n    }\n\n    //steup the effect of that expression for each context\n    setupEffect( ctx){\n\n    \n\n        if(this.ctxNodes.has(ctx)) return  this.ctxNodes.get(ctx)\n\n        const nodes = new Set()\n        this.ctxNodes.set(ctx, nodes)\n\n        if(this.updater.effect === false) return nodes\n\n\n        this.effect = watch(\n                ()=>this.getValue(ctx),\n\n                (payload)=>{\n\n                //   if(this.expression == \"attrs\")debugger\n                    //update each node\n                    // this.ctxs.forEach(ctx=>{\n                       \n                    // })\n                    this.ctxNodes.get(ctx).forEach((node)=>{\n                        const value = this.getValue(ctx)\n                        //do not use effect.lastValue, since effect is shared across the ctxs\n\n                        this.updater.updateFunction(node, {value}, this, ctx)\n\n                    })\n                },\n                {\n                    deep:this.updater.deep ?? true, \n                    updater:this.updater,   \n                }\n            \n        )\n\n        return nodes\n\n    }\n    getCtxNodes(ctx){\n\n        if(this.ctxNodes.has(ctx)) return  this.ctxNodes.get(ctx)\n        \n        const nodes = new Set()\n        this.ctxNodes.set(ctx, nodes)\n\n        return nodes\n\n    }\n    setupNode(node , ctx){\n\n        const nodes = this.setupEffect(ctx)\n\n        if(nodes.has(node) ) return    \n\n        this.setupEffect(ctx)\n\n        nodes.add(node)\n\n        this.updater.updateFunction(node, {value: this.effect?.lastValue}, this, ctx)\n    \n\n    }\n\n    removeNode(){\n\n        \n    }\n\n\n\n}\n\n\n\n\n      const textUpdater = new NodeUpdater({\n\n            priority:3,\n            id:\"text\",\n            updateFunction(node , { value}, {expression, debug}, ctx){\n\n                if(debug)debugger\n                if(node.dataset && node.dataset.la )debugger\n                // value = get(ctx.data, expression)\n                if(value && value.attrs) debugger\n                // if(typeof expression == \"function\"){\n\n                //     debugger\n                //     value = value.call(ctx.data)\n                // }\n\n                if(value && typeof value == \"object\") value = JSON.stringify(value)\n\n   \n                // if(value?.includes && value.includes(\"{{\")){\n                //     value = value.split(/({{.+?}})/g).reduce((c, v)=>{\n                //         if(!v.includes(\"{{\"))return c+v\n                //         const path = v.slice(2, -2)\n                //         return c + get(ctx.data, path)\n                //     }, \"\")\n                // }\n                \n                if(!value && value !== 0) value = \"\"\n\n                \n                node.textContent = value\n            }\n      })\n\n      const attrsUpdater = new NodeUpdater({\n            \n            priority:4,\n            id:\"attrs\",\n            updateFunction(node,{value, oldValue}, { config,expression, }, ctx){\n\n                const key = config.key\n       \n                // if(value === oldValue)return\n                if(key == \"onkeypress\")debugger\n                \n\n                node.setAttribute(key, value)\n\n                if(key == \"value\"){\n                     node.value = value\n\n                    if(!node.__inputEvent){\n\n                        node.__inputEvent = true\n                        nextTick(()=>{\n                            node.addEventListener(\"input\", (e)=>{\n                                 console.log(ctx.data, expression, e.target.value)\n\n                                 const value = getValueByInputType(e.target)\n                                set(ctx.data, expression , value)  \n\n                                nextTick(()=>{\n                                    \n                                     node.focus()\n                                })\n                            })\n                        })\n                    }\n                    \n                }\n                \n            }\n      })\n\n\n      const listenerRefs = new Map()\n      const eventsUpdater = new NodeUpdater({\n\n            priority:5,\n            id:\"events\",\n            effect:false,\n\n            // setupNode(node, payload, ctx, originalUpdate){\n\n            //     if(node.__inTemplate) {  \n            //         console.warn(\"klasdjklajsdklan eventntt\")                  \n            //         return;\n            //      }\n                      \n            //      this.updateFunction(node, payload, ctx)\n                \n            // },\n            forceUpdate(){\n                //do nothing on an update\n            },\n            updateFunction(node,_,  { expression, config}, ctx){\n\n                if(!config)debugger\n                const key = config.key\n                nextTick(()=>{\n                    this.setupEvent(node, key, expression,  ctx)\n                })\n                \n            },\n\n      })\n\n      Object.assign(eventsUpdater,{\n        setupEvent(node, event,expression, context){\n\n            let nodeRef = this.nodes.get(node)\n            if(!nodeRef) {\n                nodeRef = {}\n                listenerRefs.set(node, nodeRef)\n            }\n\n            const eventName = event\n            const listening = nodeRef.listening = nodeRef.listening || {}\n            const ctx = context.data\n            if(listening[event]){\n                if(listening[event].includes(node)) return\n                listening[event].push(node)\n        \n               const fn =  nodeRef.eventCallbacks[event] \n                \n                nextTick(()=>{\n                        node.addEventListener(eventName,  (e)=>{\n                            \n                            // console.log(\"evenntntntntnntntnt\", e, eventName)\n                         if( !listeners.includes(node))return \n                        fn.call(ctx, e,  node, ctx)    \n                    })\n                })\n               \n                return \n            }\n            const listeners = listening[event] = listening[event]  ||  []\n        \n            if(nodeRef.listening[event].includes(node) )return \n           \n            nodeRef.listening[event].push(node)\n        \n        \n            const value = expression\n        \n        \n            if(!events[\"on\"+event]) {\n                console.warn(`Event ${event} not found`)\n                return  \n            } \n            \n      \n        \n\n        \n            const fn = value\n\n\n            if(typeof value !== \"function\"){\n\n                debugger\n            }\n        \n            nodeRef.eventCallbacks = nodeRef.eventCallbacks || {}\n            nodeRef.eventCallbacks[event] = fn\n           \n            nextTick(()=>{\n    \n                node.addEventListener(eventName,  (e)=>{\n        \n                    // console.log(\"evenntntntntnntntnt\", node, e, eventName)\n                    if( !listeners.includes(node))return \n                   fn.call(ctx, e,  node, ctx )    \n               })\n            })\n        \n        \n        },\n        resolveExpression(value){\n            let isExpression, isAnonymous,  isNamed, isFunction, caller = \"\";\n\n            if(!value.startsWith) debugger\n            if(value.startsWith(\"(\")) isAnonymous = true\n            if(value.match(/^[a-zA-Z]/)) isNamed = true\n             if(!value.includes(\"(\")) caller = \"(event, node)\"\n        \n             let args = \"\"\n           \n            let stringFn = `this.${value}${caller}`\n            \n           if(isAnonymous){\n        \n                args = value.match(/\\{.+\\(([^)]+)\\)/)?.[1] || \"\"\n            \n                stringFn =`(${value})(event)`\n            }\n           \n            if(isNamed){\n                args = value.match(/\\(([^)]+)\\)/)?.[1] ||\u00A0\"\"\n            }\n        \n        \n            const code =  `\n            \n                let {${args}} = this\n        \n                ${stringFn}   \n            `\n            const  fn = new Function(\"event\",  \"node\", \"ctx\", \"window\" , code )\n        \n            return fn\n        },\n        getEventFunction(value){\n\n            let isExpression, isAnonymous,  isNamed, isFunction, caller = \"\";\n\n            if(!value.startsWith) debugger\n            if(value.startsWith(\"(\")) isAnonymous = true\n            if(value.match(/^[a-zA-Z]/)) isNamed = true\n             if(!value.includes(\"(\")) caller = \"(event, node)\"\n        \n             let args = \"\"\n           \n            let stringFn = `this.${value}${caller}`\n            \n           if(isAnonymous){\n        \n                args = value.match(/\\{.+\\(([^)]+)\\)/)?.[1] || \"\"\n            \n                stringFn =`(${value})(event)`\n            }\n           \n            if(isNamed){\n                args = value.match(/\\(([^)]+)\\)/)?.[1] ||\u00A0\"\"\n            }\n        \n        \n            const code =  `\n            \n                let {${args}} = this\n        \n                ${stringFn}   \n            `\n            const  fn = new Function(\"event\",  \"node\", \"ctx\", \"window\" , code )\n        \n            return fn\n        \n        }\n      })\n\n\n\n      //directive updaters\n      Object.entries(directives).forEach(([key, value])=>{\n\n            new NodeUpdater({id:key, ...value})\n      })\n\n  \n\n      function toRaw(obj){\n        if(typeof obj != \"object\") return obj\n\n        return obj.__raw || obj\n\n      }\n\n\n      \n  function parallelUpdate(template, newNode, ctx){\n\n    parallelTraverse(template, newNode, (node, clone)=>{\n\n        let ref = compiledRefs.get(node)\n        if(!newNode)debugger\n    \n        if(ref){\n\n            ref.runNodeUpdates(clone, ctx)\n        }\n    \n      })\n  }\n\n\n  function check(root){\n\n    const stack = [root]\n    const nodes = []\n    while(stack.length){\n        const node = stack.pop()\n\n        const childNodes = node.tagName == \"TEMPLATE\"?node.content.childNodes: node.childNodes\n\n        if(!node.__inTemplate)nodes.push(node)\n        for(let i = childNodes?.length - 1; i >= 0; i--){\n           \n            stack.push(childNodes[i])\n           \n        }\n    }\n\n    return nodes\n\n  }\n\n\n\n  function getValueByInputType(input) {\n    const { type, value, checked } = input;\n  \n    switch (type) {\n      case 'number':\n        // Convert value to number (or NaN if the value is empty)\n        return value === '' ? null : +value;\n      case 'checkbox':\n        // Return the checked property for checkboxes\n        return checked;\n      case 'radio':\n        // Return the checked property for radio buttons\n        return checked;\n      case 'date':\n        // For date inputs, return the value as a Date object (or null if empty)\n        return value === '' ? null : new Date(value);\n      case 'range':\n        // Range is a number, but it's still returned as a string, so convert to number\n        return value === '' ? null : +value;\n      case 'file':\n        // Return the FileList object for file inputs\n        return input.files;\n      default:\n        // Default case for text, password, email, etc., returns the value as a string\n        return value;\n    }\n  }\n\n\nconst isObj = (k)=>  k  && typeof k === \"object\" || typeof k === \"function\" ; \n\nclass HybridWeakMap {\n  constructor() {\n    this.weakMap = new WeakMap(); // To store object keys\n    this.map = new Map();         // To store string keys\n  }\n\n  set(key, value) {\n    if (isObj(key)) {\n      this.weakMap.set(key, value);\n\n    } else{\n      //   else if (typeof key !== \"string\") \n      // If the key is a string, store it in the Map\n      this.map.set(key, value);\n    } \n\n    return this; // For chaining\n  }\n\n  get(key) {\n    if (isObj(key)) {\n      // Retrieve from WeakMap if the key is an object\n      return this.weakMap.get(key);\n    } else {\n      // Retrieve from Map if the key is a string\n      return this.map.get(key);\n    }\n    return undefined; // If key is neither an object nor a string\n  }\n\n  has(key) {\n    if (isObj(key)) {\n      // Check in WeakMap if the key is an object\n      return this.weakMap.has(key);\n    } else  {\n      // Check in Map if the key is a string\n      return this.map.has(key);\n    }\n    return false; // If key is neither an object nor a string\n  }\n\n  delete(key) {\n    if (isObj(key)) {\n      // Delete from WeakMap if the key is an object\n      return this.weakMap.delete(key);\n    } else  {\n      // Delete from Map if the key is a string\n      return this.map.delete(key);\n    }\n    return false; // If key is neither an object nor a string\n  }\n}\n\n\n\n\n\n\n//splice like\n//a = [1,2,3,4,5]\n///b = [1,2,8, 9, 3,4,5]\n//\nfunction myCompare(a , b, alreadyValues){\n\n    const oldV = alreadyValues ? a : Object.values(a)\n    const newV = alreadyValues ? b : Object.values(b)\n\n    const largest = oldV.length > newV.length?oldV:newV\n    const len = largest.length\n    const jobs = new Set()\n\n    const move = []\n    const remove = []\n    const add = []\n    const updated =[]\n    const oldValueIndexes = new HybridWeakMap()\n\n    let index = -1\n\n    const firstEmpty = oldV.length == 0\n\n    let  offset = 0 //difference between the two arrays\n    const indexActions = []\n    while(++index < len){\n               \n\n        const actions = indexActions[index]= []\n        //just add\n        if(firstEmpty){\n\n                offset = newV.length\n\n              add.push(...Object.entries(newV))\n\n              jobs.add(\"add\")\n    \n            break;\n        }\n\n\n\n        //  offset = - removed + added \n        const oldVal = oldV[index]\n        const newVal = newV[index]\n        const existOld = oldV.hasOwnProperty(index)\n        const existNew = newV.hasOwnProperty(index)\n\n \n        if(existNew){\n            \n             //save indexes of the newValues values\n            if(!oldValueIndexes.has(newVal)){\n                oldValueIndexes.set(newVal, [])\n            }\n            if(!oldValueIndexes.has(oldVal)){\n                oldValueIndexes.set(oldVal, [index])\n            }\n\n            //asign the old\n            else if(oldValueIndexes.has(oldVal)){\n                oldValueIndexes.get(oldVal).push(index)\n            }\n\n        }\n       \n   \n\n        let oldDone \n        let newDone\n\n\n        if(oldVal == newVal) continue;\n\n        //check if the value is in the array because of the mutations theorically made\n        //[1,2,3,4,5]\n        //[1,2, -remove, +new, +new, 3,4,5 ]\n\n        //  if(2 < index)debugger\n         if(existNew && oldV.hasOwnProperty(index-offset) && oldV[index-offset] == newVal) {\n        \n            // if(!oldVal)debugger\n            updated.push([ index-offset, index, oldVal, offset,\"mutation\"])\n            // jobs.add(\"update\")\n            continue;\n         }\n       \n\n             \n        //new indexes\n         if(!existOld ){\n            // if(index >= oldV.length  ){\n          \n            offset++\n            \n            add.push([index, newVal, \"existOld\"])\n            jobs.add(\"add\")\n  \n            actions.push([\"add\", [index, newVal, \"existOld\"]])\n            continue;\n        }\n\n        //ADD\n       \n        //\n        if(existNew && !oldV.includes(newVal)){\n           \n            offset++\n            add.push([index, newVal, \"default\"])\n\n            actions.push([\"add\", [index, newVal, \"default\"]])\n           \n            jobs.add(\"add\")\n\n            //if it's  in the old, will be shift, otherwise is a delete\n            // if(newV.includes(oldVal)){\n            //     updated.push([index, oldVal, newVal , \"mutation\"])\n            // }\n          \n            oldDone = true\n             \n            newDone = true\n        }\n\n\n        //REMOVE\n        if( index < oldV.length && !newV.includes(oldVal)){\n\n            offset--\n\n            remove.push( [ index, oldVal, newVal])\n\n\n            actions.push([\"remove\", [ index, oldVal, newVal]])\n            debugger\n            jobs.add(\"remove\")\n\n            \n            oldDone = true\n       \n           \n        }\n\n        //MOVE\n        //from old to new\n        //\n        if(oldV.includes(newVal)){\n\n \n            // oldIndex, newIndex , oldVal, newVal,\n            const obj = [ undefined, index,  oldVal,  newVal,  \"oldToNew\"]\n            \n            move.push(obj)\n\n            actions.push([\"move\", obj])\n            // oldValueMoves.set(newVal, )\n   \n            jobs.add(\"move\")\n            continue\n        }\n\n     \n      \n       \n\n    }\n\n   \n \n    //update index of moves\n    \n    const l = move.length\n    let realIndex = -1\n    for(let i = 0; i < l; i++){\n\n        realIndex++\n\n        const m = move[realIndex]\n\n        debugger\n\n        //old index of new value\n        const newVal = m[3]\n        if(!oldValueIndexes.has(newVal)){\n            debugger\n        }\n        //if the value is repeated the could have multiple indexes\n        //so go removing indexes\n        const indexes = oldValueIndexes.get(newVal)\n\n        if(!indexes) {\n            \n            throw new Error(\"The value should have index\") \n        }\n\n\n        //if is longer than one, remove the first one\n        //this maybe means that the value is added...\n        //because the new value has more of the same value than the old array\n        if(!indexes.length) {\n\n            realIndex--\n            move.splice(realIndex, 1)\n            add.push([m[1], m[3], \"move\"])\n            jobs.add(\"add\")\n            offset++\n\n            debugger\n            continue; \n        }\n        \n        // const index = indexes.length > 1 ? indexes.shift() :indexes[0]\n        const index = indexes.shift() \n\n        //index is equal to the new index, it's a new value\n        if(index == m[1]){\n\n            realIndex--\n            move.splice(realIndex, 1)\n            add.push([m[1], m[3], \"move\"])\n            jobs.add(\"add\")\n            offset++\n\n            continue \n\n        }\n\n        if(typeof index !== \"number\")debugger\n        m[0] = index\n    }\n\n    if(move.length == 0 && jobs.has(\"move\")){\n        jobs.delete(\"move\")\n     }\n\n   \n\n    if(offset + oldV.length !== newV.length){\n\n        debugger\n        console.log(offset , oldV.length, newV.length)\n       console.error(\"The arrays are not the same length\", offset , oldV.length, newV.length)\n     } \n\n    \n    return { \n        indexActions,\n        jobs,\n        add ,\n        remove,\n        move,\n        oldValueIndexes,\n        updated,\n        offset\n    }\n\n}\n"],
  "mappings": "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",
  "names": ["prefix", "events", "directives", "node", "oldValue", "value", "key", "args", "ref", "expression", "ctx", "loopKey", "loopIndex", "path", "get", "item", "childData", "reactive", "payload", "update", "helper", "type", "target", "updateId", "items", "createFragment", "holders", "oldFragment", "holder", "template", "nodeObj", "last", "loop", "comparison", "myCompare", "jobs", "indexMap", "valueMap", "oneJob", "newUpdate", "groupState", "index", "obj", "nextTick", "from", "to", "entireMove", "fromIndex", "toIndex", "toObj", "fromRef", "childCtx", "newNode", "child", "i", "parallelUpdate", "indexGroup", "lastInGroup", "group", "nodes", "createContext", "watch", "data", "root", "getPrevious", "compiled", "compileHelpers", "runUpdates", "proxies", "isProxyFlag", "isReactive", "interceptors", "reciever", "k", "v", "callbacks", "parent", "origin", "current", "handler", "ReactiveHandler", "proxy", "effectStack", "_ReactiveHandler", "options", "effect", "depth", "deep", "observingProps", "parents", "deepEffect", "deepEffects", "Effect", "toRaw", "currentEffect", "oldKey", "Manager", "effect", "callback", "options", "Effect", "_Effect", "target", "toRaw", "handler", "ReactiveHandler", "source", "props", "prop", "value", "payload", "isReactive", "reactiveHandler", "observing", "watch", "runOrOption", "t", "set", "obj", "path", "keys", "lastKey", "key", "Manager", "_Manager", "queue", "nextTick", "getCache", "get", "val", "getPrevious", "CompiledRef", "v", "attr", "k", "ref", "id", "compiledRefs", "idCounter", "nodeUpdateQueue", "registerNodeUpdate", "template", "node", "ctx", "runningQueue", "updateQueue", "cloneOrCtx", "childCtx", "parallelUpdate", "compiledRefs", "updateNode", "compileHelper", "isTemplate", "children", "fastParse", "child", "NodeHelper", "helper", "attrs", "attr", "value", "key", "prefix", "directiveKey", "directives", "events", "templateRef", "ref", "compileHelpers", "root", "fastTraverseDOM", "runUpdates", "show", "text", "loop", "NodeUpdater", "processNode", "stack", "newTemplate", "childNodes", "str", "result", "start", "openBrace", "noExpression", "closeBrace", "path", "updateNode", "root", "ctx", "stack", "node", "ref", "compiledRefs", "childNodes", "i", "parallelTraverse", "clone", "callback", "children", "cloneChildren", "NodeHelper", "node", "updaters", "idCounter", "registerNodeUpdate", "compiledRefs", "id", "expression", "config", "updater", "NodeUpdater", "update", "NodeUpdate", "ctx", "force", "options", "key", "obj", "prop", "proto", "NodeUpdate", "updater", "rawExpression", "config", "exp", "debug", "node", "ctx", "value", "get", "nodes", "watch", "payload", "textUpdater", "NodeUpdater", "expression", "attrsUpdater", "oldValue", "key", "nextTick", "e", "getValueByInputType", "set", "listenerRefs", "eventsUpdater", "_", "event", "context", "nodeRef", "eventName", "listening", "fn", "listeners", "events", "isExpression", "isAnonymous", "isNamed", "isFunction", "caller", "args", "stringFn", "code", "directives", "toRaw", "obj", "parallelUpdate", "template", "newNode", "parallelTraverse", "clone", "ref", "compiledRefs", "getValueByInputType", "input", "type", "value", "checked", "isObj", "k", "HybridWeakMap", "key", "myCompare", "a", "b", "alreadyValues", "oldV", "newV", "len", "jobs", "move", "remove", "add", "updated", "oldValueIndexes", "index", "firstEmpty", "offset", "indexActions", "actions", "oldVal", "newVal", "existOld", "existNew", "oldDone", "newDone", "obj", "l", "realIndex", "i", "m", "indexes"]
}
