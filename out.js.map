{
  "version": 3,
  "sources": ["src/reactive-dom.js"],
  "sourcesContent": ["\n/**\n * \n Framework to manipulate directly de the DOM using reactive programming.\n */\n\n\n const prefix = \"s-\"\n const events = {\n    // Mouse Events\n    onclick: true,\n    ondblclick: true,\n    onmousedown: true,\n    onmouseup: true,\n    onmousemove: true,\n    onmouseover: true,\n    onmouseout: true,\n    onmouseenter: true,\n    onmouseleave: true,\n    oncontextmenu: true,\n  \n    // Keyboard Events\n    onkeydown: true,\n    onkeyup: true,\n    onkeypress: true,\n  \n    // Form Events\n    onchange: true,\n    onsubmit: true,\n    onreset: true,\n    oninput: true,\n    oninvalid: true,\n    onselect: true,\n  \n    // Window Events\n    onload: true,\n    onunload: true,\n    onresize: true,\n    onscroll: true,\n    onbeforeunload: true,\n    onhashchange: true,\n    onerror: true,\n  \n    // Document Events\n    onDOMContentLoaded: true,\n    onreadystatechange: true,\n  \n    // Clipboard Events\n    oncopy: true,\n    oncut: true,\n    onpaste: true,\n  \n    // Drag and Drop Events\n    ondrag: true,\n    ondragstart: true,\n    ondragend: true,\n    ondragover: true,\n    ondragenter: true,\n    ondragleave: true,\n    ondrop: true,\n  \n    // Media Events\n    onplay: true,\n    onpause: true,\n    onended: true,\n    ontimeupdate: true,\n    onvolumechange: true,\n    onseeked: true,\n    onseeking: true,\n    ondurationchange: true,\n    oncanplay: true,\n    oncanplaythrough: true,\n  \n    // Touch Events\n    ontouchstart: true,\n    ontouchend: true,\n    ontouchmove: true,\n    ontouchcancel: true,\n  \n    // Pointer Events\n    onpointerdown: true,\n    onpointerup: true,\n    onpointermove: true,\n    onpointerover: true,\n    onpointerout: true,\n    onpointerenter: true,\n    onpointerleave: true,\n    onpointercancel: true,\n  \n    // Focus Events\n    onfocus: true,\n    onblur: true,\n    onfocusin: true,\n    onfocusout: true,\n  \n    // Device Events\n    ondeviceorientation: true,\n    ondevicemotion: true,\n  \n    // Miscellaneous Events\n    ontransitionend: true,\n    onanimationstart: true,\n    onanimationend: true,\n    onanimationiteration: true,\n    onmessage: true,\n    ononline: true,\n    onoffline: true,\n    onstorage: true,\n  };\n\n\n const directives = {\n    \n\n    bind: {\n        updateFunction(node, { oldValue, value}){\n\n            if(typeof value === \"object\"){\n    \n                Object.entries(value).forEach(([key, value]) => {\n                    \n                    node.setAttribute(key, value)\n                });\n            }\n\n        },\n\n        \n    },\n    show: {\n   \n        updateFunction:(node, { value})=>{\n\n            const args = value ? [\"\"]: [\"none\", \"important\"]\n             node.style.setProperty('display',...args);\n            // return {\n            //     style: {display: args}\n            // }\n            \n        },\n       \n    },\n\n    if:{\n\n        updateFunction(node, { value}){\n            let ref = nodeRef.commentRef = nodeRef.commentRef || document.createComment(\"if\")\n    \n            if(value){\n                \n                if(node.parentNode) return\n                ref.replaceWith(node)\n \n            }else{\n\n                node.replaceWith(ref)\n                \n            }\n        },\n       \n    },\n\n\n    //loop first to pass the apropiate data to the children\n    loop: {\n\n        //set deep to one to avoid nested updates\n        deep:1,\n        resolveExpression(expression){\n            //[m,loopKey, loopIndex,  path]\n            return expression.match(/([a-zA-Z]+)(?:\\s*,\\s*([a-zA-Z]+))?\\s+in\\s+([a-zA-Z.]+)/).slice(1)\n        },\n        getValue({expression}, data){\n\n            let [ loopKey, loopIndex, path ] = expression\n\n            return get(data, path)\n        \n        },\n \n        createChildContext({path, obj,ctx, loopKey, loopIndex}){\n            return {data:new Proxy(ctx.data, {\n                get(target, prop){\n\n                    if(prop == loopIndex){\n                         return obj.key\n                    }\n                    if(prop == loopKey){\n                        \n                        const key = obj.key\n                        \n                        const v =  get(target, `${path}.${key}`)\n\n                        return v\n                    }\n                    return Reflect.get(target,prop)\n\n                },\n        \n                set(target, prop, v){\n                    if(prop == loopIndex){\n                        return true\n                    }\n                    if(prop == loopKey){\n      \n                        return set(target, `${path}.${obj.key}`, v)\n                       \n                    }\n                    return Reflect.set(target,prop, v)\n                }\n            }), isLoop:true}\n        },\n        updateFunction(node, update, {expression, helper} , ctx){\n\n            const {type, target, key,value, updateId, oldValue} = update\n    \n            const  [ loopKey, loopIndex , path] = expression \n            const items = value\n   \n            const createFragment = (holders, oldFragment)=>{\n                const holder = document.createElement(\"div\")\n                holders.push(holder)\n                if(oldFragment) holder.append(...oldFragment.childNodes)\n                return holder\n            }\n            let template = helper.node.content\n\n            if(!node.parentNode)debugger\n\n            if(!items) return \n            \n            \n            const nodeObj = this.getNodeObject(node)  \n            const last = nodeObj.lastLoop ||[]\n             console.time(\"Comparison\")\n            const comparison = compare( items,last)\n\n            const jobs = comparison.jobs\n             console.timeEnd(\"Comparison\")\n\n             const oneJob = jobs.length === 1?jobs[0]:false\n\n             if(oneJob ==\"keep\") return\n\n             //TODO: UPDATE NODES EACH TIME to overwrite the context\n             // just update new nodes\n             // remove old nodes\n             // advantatges:\n                // no need of references and other staff like loopNodes, etc\n             //TODO: SELECTIVE UPDATE\n             // try to find way to add the nodes in the corresponding position\n             //cons: \n                //the unique con of this is that I need to manipulate the DOM\n                //but maybe there is no such operations where there differents indexes...\n                // the most comomn is splice which will delete and add lists of nodes so == one reflow\n   \n\n             const loopNodes = nodeObj.loopValues = nodeObj.loopValues || new Map()\n            // let loopNodes = nodeObj.loopValues = nodeObj.loopValues || []\n                 //clean deleted refences\n            // loopNodes = loopNodes.filter(v=>v)\n            const newUpdate = []\n\n            const holders = []\n            const inLoop = ctx.isLoop\n            const sameLength = ( comparison.toAdd.length == comparison.toRemove.length  \n                && !comparison.toReposition.length \n              );\n       \n            //skip update when the length is the same and all the values are the same type\n            if(sameLength && comparison.types.length == 1 && comparison.types[0] != \"object\") return\n\n\n            console.log(\"proceeed\")\n\n            const afterUpdate = []\n            comparison.toKeep.forEach(([key, item], index)=>{\n\n                const obj = loopNodes.get(key)\n\n                if(!obj)debugger\n                const newObj = inLoop ? createFragment(holders):document.createDocumentFragment()\n                newObj.append(...obj.nodes)\n\n                newUpdate[key] = newObj\n\n            \n             })\n\n            \n             console.log(\"UPDATE LOOP\", {comparison, loopNodes, items})\n            //remove old\n            comparison.toRemove.forEach(([key, item], index)=>{\n\n\n                // //string udpate \n                // if(sameLength && typeof item !== \"object\" &&  typeof item == typeof comparison.toAdd[index][1]){\n                //     return\n                //  }\n\n                const obj = loopNodes.get(key)\n               \n\n                //delete on next, so i have access on the same update\n                 afterUpdate.push(()=> loopNodes.delete(key))\n            \n\n                if(!obj) debugger\n\n                obj.nodes.forEach(node=>node.remove())\n\n             })\n\n\n            //  if(!jobs.includes(\"add\")) {\n\n            //     Object.entries(items).forEach(([key, item])=>{\n            //          const obj = loopNodes.get(key)\n            //         const childCtx = this.createChildContext({path, obj,ctx, loopKey, loopIndex})\n                    \n            //         obj.nodes.forEach(node=>updateNode(node, childCtx))\n            //     })\n            //     console.log(\"only removed\")\n\n            //     afterUpdate.forEach(fn=>fn())\n            //     return\n            //  } \n            \n            //update position\n             comparison.toReposition.forEach(([key, item, oldKey], index)=>{\n\n                \n                const obj = loopNodes.get(oldKey)\n    \n                afterUpdate.push(()=> loopNodes.set(key, obj))\n \n                const newObj = inLoop ? createFragment(holders):document.createDocumentFragment()\n\n                if(!obj)debugger\n                newObj.append(...obj.nodes)\n\n                obj.key = key\n                //update for the index....\n                  updateNode(newObj, obj.ctx)\n                  \n               \n                newUpdate[key] = newObj\n             })\n\n\n             //add new\n             comparison.toAdd.forEach(([key, item], index)=>{\n                \n          \n                //set obj before update \n                const obj = { key, item}\n                const childCtx = this.createChildContext({path, obj,ctx, loopKey, loopIndex})\n        \n          \n                afterUpdate.push(()=> loopNodes.set(key, obj))\n               \n                obj.ctx = childCtx\n\n\n                // faster 100ms //without console around 55ms\n                  let newNode = template.cloneNode(true)\n                  template.childNodes.forEach((child, i)=>{\n                        parallelUpdate(child, newNode.childNodes[i], childCtx)\n                        //i don't know why if I register and run it on the queue \n                        //doesn't trigger the update on {{task.name}}\n                    //   registerNodeUpdate(child, newNode.childNodes[i], childCtx)\n                  })\n\n    \n                 \n                  //slower: from 100ms to 130ms //without console aroudn 65ms\n                // let newNode = cloneDeep(template, (node, ref, )=>{\n            \n                //     if(node.tagName == \"TEMPLATE\")debugger\n                //     if(!ref) return   \n                //      ref.runNodeUpdates(node, childCtx)\n        \n                // }, )\n        \n                if(ctx.isLoop && newNode.nodeType == 11){\n                \n                    newNode = createFragment(holders, newNode)\n                }\n\n\n                obj.nodes = [...newNode.childNodes]\n          \n                newUpdate[key] = newNode\n\n               \n               \n             })\n\n\n             //do local updates\n             afterUpdate.forEach(fn=>fn())\n\n             //check duplicated\n            //  nextTick(()=>{\n            //     const duplicated = [...loopNodes.values()].reduce((c,v, i, a)=>a.indexOf(v) !== i?c.concat(v):c, [])\n            //     if(duplicated.length){\n            //         debugger\n            //     }\n            //  })\n\n\n             if(items.length != newUpdate.length) debugger\n\n            //  debugger\n            // newUpdate = newUpdate.filter(v=>v)\n\n            if(node.__inTemplate)debugger\n\n            updateQueue()\n\n              requestAnimationFrame(()=>{\n                node.before(...newUpdate)\n              })\n          \n\n\n            holders.forEach(holder=>holder.replaceWith(...holder.childNodes))\n\n            nodeObj.lastLoop = [...items]\n\n            return \n\n\n            \n        },\n        \n\n    }\n    \n    \n}\n \n\nwindow.createContext = createContext\nwindow.reactive = reactive\nwindow.watch = watch\nwindow.nextTick = nextTick\n\nfunction createContext(data, root){\n\n  \n     root = root || getPrevious() ||\u00A0document.body\n\n \n\n    if(typeof data === \"string\") {\n        data = reactive({})\n    }\n        \n    const ctx =   {\n        data,\n        root,\n    }\n\n    console.time(\"Compilation\")\n    //  let compiled = compileNodes(root,  ctx )\n     let compiled = compileHelpers(root )\n\n     console.timeEnd(\"Compilation\")\n\n     console.log(\"compiled\", compiled)\n\n\n      runUpdates(ctx)\n    //  initializeNodes(ctx)\n     \n     return {}\n}\n\n\n\nconst proxies = {\n    reactive: new WeakMap()\n}\n\nconst isProxyFlag = Symbol('__isProxy');\n\nfunction isReactive(obj){\n    if(!obj) return false\n    // if(typeof obj !== \"object\") return false\n    // console.log(obj)\n    //  return obj.__raw ? true: false\n     return obj?.__isReactive\n\n}\nconst interceptors = {\n\n    //chat gpt solution for check proxies with prototypes\n    //IMPORTANT: do not delete this\n     // Intercept and return `false` for the `hasOwnProperty` check on the flag\n    //  hasOwnProperty:{\n    //     get(target, key, value, receiver){\n\n    //         if (prop === 'hasOwnProperty') {\n    //             return (key) => key !== isProxyFlag;\n    //           }\n    //           return Reflect.get(target, key, receiver);\n    //     }\n    //  },\n     \n      \n    //   [isProxyFlag]:{\n    //         get(target, key){\n    //               // Intercept access to the symbol-based flag\n    //             if (prop === isProxyFlag) {\n    //                 return true;  // Indicate that this object is proxied\n    //             }\n    //             return Reflect.get(target, key, receiver);\n    //         }\n    //   },\n\n    __isReactive:{\n\n        get(target, key, value, reciever){\n            \n    \n            return this.proxy == reciever\n\n            return reciever == this.target\n        },\n\n    },\n    __raw:{\n        get(target){\n            // console.log(\"the targettt\", target)\n            return target\n            return this.target\n        }\n    },\n    \n  \n }\n \n\n\nfunction reactive(obj, callbacks = [],  parent,key,  origin){\n\n    if(typeof obj !== \"object\") return obj\n\n    if(isReactive(obj)) {\n       \n        obj.__parent  = parent\n        obj.__key = key\n \n        debugger\n         return obj\n \n     }\n \n\n    let current =  proxies.reactive.get(obj)\n\n    if(current ) {\n            return current\n    }\n\n    let handler =   new ReactiveHandler({target:obj, parent,key, origin:origin ||\u00A0obj,callbacks })\n    let proxy =  new Proxy(obj, handler)\n\n    handler.proxy = proxy\n    proxies.reactive.set(obj,proxy)\n\n        return proxy\n } \n\n\n  const effectStack = []\n class ReactiveHandler{\n\n    static handlers = []\n    \n    static queue = []\n    static handlersByObject = new WeakMap()\n    constructor(options = {}){\n\n        this.effects = new Set()\n\n        this.constructor.handlers.push(this)\n\n        this.origin = options.origin\n        this.target = options.target\n\n        this.queue = []\n\n        //instead of an array of parents just pass the \n        this.parent = options.parent\n        this.key = options.key\n\n        this.deepEffects  = new Set()\n\n        \n        if(options.callbacks){\n            this.addDeepEffect(options.callbacks)\n        }\n\n    \n        this.constructor.handlersByObject.set(this.target, this)\n    }\n  \n    //use the handler to run the logic, since the handler has control on the time and data to update\n    runEffect(effect, depth ){\n\n        if(effect.ran) return\n        nextTick(()=> effect.ran = false)//setTimeout(()=> effect.ran = false)\n\n        \n        const isFunction = typeof effect == \"function\" \n        const deep = isFunction?true:effect.deep\n        if(depth && deep){\n     \n            //check depth\n            if( deep !== true && depth > deep)  return\n\n            this.runNextUpdate(effect)            \n\n        }\n        //without depth only run the obersving props\n        if(!depth){\n\n            const observingProps = effect.observing.get( this)\n\n            this.runNextUpdate(effect, observingProps)\n\n        }\n  \n\n       \n    }\n\n    runDeep(){\n\n            //generate an inverted deep   // src/explanations.txt #invertedDeep\n            let deep = 1\n            let current = this\n            const parents = []\n    \n            console.log(\"hadn\", this, this.nextUpdate)\n            // let path = []\n            let path = \"\"\n            while(current){\n\n                if(current.key){\n                    // path.unshift(current.key)\n                    path = `${current.key}.${path}`\n                }\n                \n                parents.push([current, deep, path])\n                current = current.parent\n                deep++\n            }\n\n            console.log(\"parents\", parents)\n            //run first main parent effect\n            parents.reverse()\n    \n            parents.forEach(([handler, depth, path])=>{\n\n                const payload = {path}\n                console.log(payload)\n              \n                handler.deepEffects.forEach(effect=>{\n\n                \n                    this.runEffect(effect, depth)\n              \n                })\n            })\n    }\n\n    runNextUpdate(effect, observingProps = this.nextUpdate){\n\n        if(!observingProps)debugger\n        Object.keys(observingProps).forEach((key)=>{\n\n            if(typeof effect == \"function\"){\n                effect(this.nextUpdate[key], this)\n                return \n            }\n\n            effect.runWithPayload(this.nextUpdate[key], this)\n        })\n\n\n    }\n\n    addDeepEffect(deepEffect){\n        \n\n        const deepEffects = this.deepEffects\n        if(typeof deepEffect  == \"function\" || deepEffect instanceof Effect){\n        \n            deepEffects.add(deepEffect)\n\n        }\n        else if(Array.isArray(deepEffect) ){\n            deepEffects.forEach(effect=>{\n                this.addDeepEffect(effect)\n            })\n           \n        }\n        else{\n            console.warn(\"deepEffects must be an array, a function or an Effect\")\n        }\n    }\n\n    static get currentEffect(){\n        return effectStack.at(-1)\n     }\n     static set currentEffect(v){\n         if(v){\n             effectStack.push(v)\n         }else{\n             effectStack.pop()\n         }\n         return true\n      }\n\n    static getHandler(obj){\n\n       return  this.handlersByObject.get(toRaw(obj))\n    }\n\n    addEffect(effect, key, target){\n\n  \n        if(!this.effects.has(effect)) this.effects.add(effect )\n\n        //ad property to the list of observing propertis of the effect\n        effect.observeProp(this, key)\n      \n\n    }\n    \n    get(target, key, reciever){\n\n         let value = target[key]\n        // let value = Reflect.get(target, key)\n\n        if(interceptors[key]?.[\"get\"]){\n            return interceptors[key][\"get\"].call(this,target, key, value, reciever )\n        }\n\n\n\n        //trigger get\n        const currentEffect = this.constructor.currentEffect\n\n\n        // if(Array.isArray(target) && target.length == 3) debugger\n        if( currentEffect){\n                // if(key == \"style\" &&  this.origin.attrs)debugger\n             this.addEffect(currentEffect, key)\n            // this.addDeepEffect(currentEffect)\n\n        }   \n\n    \n        if(typeof value === \"object\"){\n            return reactive(value, false, this ,key, this.origin,  )\n        }\n\n   \n\n       \n        if(Array.isArray(target) ){\n\n            // return handleArrayFunctions(key, target, value, this)\n\n        }\n\n        \n        return value\n    }\n\n    \n      \n\n\n    // apply(target, thisArg, args){\n\n    // }\n    set(target, key, value, reciever){\n\n        //trigger update\n       \n\n        if(interceptors[key]?.[\"set\"]){\n            return interceptors[key][\"set\"].call(this,target, key, value, reciever,  )\n        }\n\n\n        let oldKey \n\n        const oldValue = target[key]\n\n        if(Array.isArray(target)){\n        \n            // if (key === 'length') {\n            //     // Handle changes to the array's length, especially when removing elements\n            //     updateViewCallback('lengthChange', target);\n            // }\n              \n            //   // Handle direct changes to array elements (e.g., arr[2] = 'new value')\n            //   const oldValue = target[key];\n            //   target[key] = value;\n            // if (oldValue !== value) {\n            //     updateViewCallback('elementChange', target, key);\n            // }\n\n\n         \n            // if(Array.isArray(target)){\n            //   oldKey = target.indexOf(oldValue)\n            // }\n\n            // debugger\n\n          \n        }\n\n\n        // Reflect.set(target, key, value)\n         target[key] = value\n\n        //has no much difference on performance\n        //    if(Array.isArray(target) && key !== \"length\") return true\n\n        console.log(\"queueeeinggg\", target, key, value)\n        this.queueMutation({type:\"set\", target, key,oldKey, value, oldValue, origin:this.origin})\n        \n        return true\n    }\n    deleteProperty(target, key) {\n        if (key in target) {\n\n            \n            \n            const oldValue = target[key]\n            let oldKey \n            if(Array.isArray(target)){\n              oldKey = target.indexOf(oldValue)\n            }\n\n          delete target[key];\n\n\n          this.queueMutation( {type: \"delete\",value:target[key],oldKey, target, key,oldValue,  origin:this.origin} )\n\n          return true\n          // Expected output: \"property removed: texture\"\n        }\n      }      \n\n    triggerUpdate(){\n\n        // TODO: I think that I can merge all this in to the same funtions, \n        // I don't need deepEffects and effects, just one Set of effects\n\n        //run deep effects\n        this.runDeep()\n\n       //handle own effects\n        this.effects.forEach(effect=>{\n\n\n            this.runEffect(effect)\n\n            // effect.updateWithHandler(this)\n           \n            \n        })\n       \n        this.nextUpdate = false\n    }\n\n    static runUpdates(){\n\n        // console.log(\":::::RRRRunning update\")\n        // this.queue.forEach((reactiveHandler )=> {\n        //     reactiveHandler.triggerUpdate()\n        // })\n        // this.queue.length = 0\n\n\n        while(this.queue.length) {\n            const reactiveHandler =  this.queue.shift()\n            reactiveHandler.triggerUpdate()\n        }\n \n        this.updating = false\n\n         Manager.runNextTick()\n    }\n\n    \n\n    queueMutation(payload){\n\n        //push mutation to the queue\n        ReactiveHandler.queue.includes(this) ||\u00A0 ReactiveHandler.queue.push(this)\n\n\n        //prepare set properties changes in this object\n        this.nextUpdate = this.nextUpdate || {}\n        //  new Proxy({}, {set(t,k,v){\n        //     if(k == \"more\") debugger\n        //     return t[k] = v\n        // }})\n\n\n        console.log(\"neewww\", payload, this)\n        // if(Array.isArray(payload.target))debugger\n        //save payload in an object, so last value update is triggered only\n        this.nextUpdate[payload.key] = payload\n\n        if(!ReactiveHandler.updating){\n            ReactiveHandler.updating = true\n        \n            console.time(\"Collect updates\")\n            // console.trace();\n\n            // ReactiveHandler.runUpdate()\n            // (async ()=>{\n\n            //     ReactiveHandler.runUpdate()\n            // })(window)\n            //  requestAnimationFrame(()=>{\n            //     // console.log(\"tringgering update\")\n            //     console.timeEnd(\"Collect updates\")\n              \n            //     ReactiveHandler.runUpdates()\n            //   })\n\n              Promise.resolve().then(()=>{\n\n\n                console.log(\"tringgering update\")\n                console.timeEnd(\"Collect updates\")\n              \n                ReactiveHandler.runUpdates()\n              })\n         \n        }else{\n\n            console.warn(\"is this mutation registering\", payload)\n\n            // debugger\n        }\n    }\n\n\n }\n\n\n\n\n function compute(computation){\n\n\n    let val \n\n    effect((payload)=>{\n\n        val = computation(payload)\n    })\n\n    return val\n\n\n\n }\n\n function effect(callback, options){\n\n    options = {\n        ...(options||{})\n    }\n     new Effect(callback, options)\n\n }\n\n\n\n class Effect{\n\n    onTrigger = false\n    handler = false\n    immediate = true\n    deep = false\n\n    static eventTarget = new EventTarget()\n    static observingTarget = new WeakMap()\n\n    static setTargetObserver(effect, target){\n\n        target = toRaw(target)\n\n       let handler =  ReactiveHandler.getHandler(target)\n\n       if(handler){\n\n            if(typeof effect == \"function\")debugger\n            handler.addDeepEffect(effect)\n            \n       }else{\n\n        console.warn(\"no handler found\", target)\n       }\n      \n  \n    }\n    constructor(source, options){\n\n        const props = [\"immediate\", \"callback\",  \"onTrigger\", \"deep\", \"updater\"]\n\n        this.source = source\n\n        if(typeof source == \"object\"){\n            \n            this.deep = 1\n            Effect.setTargetObserver(this, source)\n        }\n\n        props.forEach(prop=>{\n            if(options.hasOwnProperty(prop)) this[prop] = options[prop]\n        })\n\n        //[handler] - {[key]:true} observing\n        this.observing = new WeakMap()\n\n        //initiliaze the effect\n        let value = this.runWithPayload({})\n\n\n        //run callback\n        if(this.immediate && this.callback){\n\n            this.callback.call(undefined, {value})\n        }\n\n        this.nextUpdate = {}\n\n    }\n\n\n    runWithPayload(payload, handler){\n\n        //the effect can run on multiple payload, since updats are collected \n        let source = this.source\n\n        let value \n\n        ReactiveHandler.currentEffect = this\n\n        if(typeof source == \"function\") value = source(payload, handler)\n\n        this.lastValue = value\n         \n        //observe result object\n       if(this.deep && isReactive(value)){\n    \n            Effect.setTargetObserver(this, value)\n       }\n\n       ReactiveHandler.currentEffect = false\n\n       if(this.callback ){\n            this.callback.call(undefined, payload)\n        }\n\n       return value\n\n    }\n   \n    observeProp(reactiveHandler, prop){\n\n        let observing = this.observing.get(reactiveHandler) \n        if(!observing) {\n            observing = {}\n            this.observing.set(reactiveHandler, observing)\n        }\n\n        observing[prop] = true\n    }\n }\n\n\n\n\n function watch(source, callback, runOrOption ){\n\n    const run = typeof runOrOption === \"boolean\" ? runOrOption : false\n   \n    \n    const options = {\n        callback, immediate: run,\n        ...(runOrOption ||{})\n    }\n    let t = typeof source \n\n\n    if(t !== \"object\" && t !== \"function\"){\n\n        console.warn(\"watch source must be an object or a function\")\n        return\n    } \n    \n\n    effect(source, options)\n    \n    \n }\n\n\n\n\n\n    function set(obj, path, value){\n            \n        if(!path?.split)debugger\n            let keys = path.split(\".\")\n\n            let target = obj\n            let lastKey = keys.pop()\n    \n            for(let key of keys){\n                if(!target) return \n                target = target[key]\n            }\n    \n            target[lastKey] = value\n\n    }\n\n\n    class Manager{\n        static isRendering = false\n        static runNextTick(){\n\n            if(this.isRendering ) {\n                // setTimeout(()=>this.runNextTick(), 0)\n              \n                // requestAnimationFrame(()=>{\n                //     this.runNextTick()\n                // })\n                 return\n            } \n            this.isRendering = true;\n\n\n            // const queue = [...Manager.nextTickQueue]\n            const queue = Manager.nextTickQueue\n             // Execute all the queued callbacks\n             //this makes inputs be able to focus on the nextTick\n             //this doesn't affect the real time of renderization\n             requestAnimationFrame(()=>{\n                while ( queue.length) {\n                    const callback = queue.shift();\n                    callback();  // Run the callback\n                }\n                 // Mark rendering as done, so further nextTicks can be scheduled\n                 this.isRendering = false;\n              })\n\n        }\n       \n\n       static nextTickQueue = []\n    }\n\n\n    function nextTick(callback){\n            \n        Manager.nextTickQueue.push(callback)\n\n      \n \n    }\n\n\n\n    const getCache = new Map()\n\n    Manager.getCache = getCache\n    \n    function get(obj, path){\n\n        // let cache = getCache.get(obj) \n        \n        // if(cache && cache[path]){\n        //     return cache[path]\n        // }\n        if(!path?.split)debugger\n\n        const keys = path.split(\".\")\n        let target = obj\n\n        let val\n        for(let key of keys){\n            if(!target) {\n                val = undefined\n                break;\n            } \n            target = target[key]\n        }\n\n        val = target\n        \n        // if(!cache){\n        //     cache = {}\n           \n        //     //   getCache.set(obj, {[path]:val})\n        // }\n        // cache[path] = val\n\n        return val\n\n    }\n\n\n\n\n\n\n      function getPrevious(){\n        // Select the script element\n        const currentScript = document.currentScript;\n        // Get the previous sibling element\n\n        return currentScript.previousElementSibling;\n\n\n      }\n\n      \n\n/**\n * \n  Compile the nodes of the root element into an referenced object\n\n{\n  node: <Node>,\n  textContent: <String>,\n    attrs: {\n        <attrName>: <attrValue>,\n        ...\n    },\n    events: {\n        <eventName>: <eventHandler>,\n        ...\n    }\n  }\n */\n\n\nclass CompiledRef {\n    constructor(){\n\n        this.map = new Map()\n        this.idMap = new Map()\n    }\n    get(v){\n        // if(!v?.__sId) debugger\n        if(v?.__sId){\n            \n          return this.idMap.get(v.__sId)\n        }\n        let attr = v?.getAttribute?v.getAttribute(\"__sId\"):false\n        if(attr){\n            return this.idMap.get(attr)\n        }\n       return  this.map.get(v)\n    }\n    set(k, ref){\n         this.map.set(k, ref)\n\n       return  this.idMap.set(ref.id, ref)\n    }\n    has(v){\n        return this.map.has(v)\n    }\n    getByDepth(id){\n\n        return this.idMap.get(id)\n\n    }\n}\nconst compiledRefs = new CompiledRef()\nconst updateNodesQueue = new WeakMap()\n\nlet idCounter = 0;\n\n\nconst nodeUpdateQueue = []\nfunction registerNodeUpdate(template, node, ctx){\n\n    nodeUpdateQueue.push([template, node, ctx])\n\n}\nlet runningQueue = false\nfunction updateQueue(ctx){\n    \n        if(runningQueue)return \n        runningQueue = true\n       \n        // console.log(\"running queue\")\n        // nodeUpdateQueue.reverse()\n        while(nodeUpdateQueue.length){\n            const [node, cloneOrCtx, childCtx] = nodeUpdateQueue.pop()\n      \n            if(childCtx){\n                \n                debugger\n                parallelUpdate(node, cloneOrCtx, childCtx)\n            }else{\n\n                compiledRefs.get(node).runNodeUpdates(node, childCtx || ctx)\n\n            }\n        }\n\n        runningQueue = false\n        // nodeUpdateQueue.length = 0\n}\nfunction compileHelper(node, isTemplate){\n\n\n       \n        if( node.__sCompiled ) return compiledRefs.get(node)\n         //save compiled prop for faster access\n\n        let  nodeRef = {\n            updaters:{}\n        }\n      \n    \n        //set the id \n        if(node.dataset) {\n            // node.dataset.__sId = nodeRef.id\n            // node.setAttribute(\"__sId\", nodeRef.id)\n        }\n    \n        let setNode = false\n\n       \n        if(node.tagName !== \"TEMPLATE\") node.__inTemplate = isTemplate\n\n\n\n        //compile text nodes\n        if ( node.nodeType == node.TEXT_NODE && node.textContent.includes(\"{{\") ) {\n         \n            setNode = true\n    \n            let children = fastParse( node.textContent)\n            \n            children = children.map(child=>{\n                if(child.path){\n                              \n                    const node = document.createTextNode(`{{${child.path}}}`)\n                    node.__inTemplate = isTemplate\n                    \n                    const helper =  new NodeHelper(node )\n                    helper.addUpdate(\"text\", {expression:child.path})\n\n                    return node\n                }\n\n                const node = document.createTextNode(child)\n                node.__inTemplate = isTemplate\n\n                return node\n                \n            })\n\n\n             node.replaceWith(...children)\n                \n        }\n    \n        //compile other nodes\n        if(node.attributes?.length){\n           \n            let helper \n                \n            const attrs = node.attributes; // Get all attributes of the element\n            Object.values(attrs).forEach((attr) => {\n                let value = attr.value;\n                let key = attr.name\n    \n                //DIRECTIVES\n                if(key.startsWith(prefix)){\n\n                        helper = helper || new NodeHelper(node )\n                    \n                    let directiveKey = key.slice(2)\n                    if(directives[directiveKey]){\n                        \n                        setNode = true\n\n                        helper.addUpdate(directiveKey, {expression:value.slice(2, -2)})\n                        \n                        node.removeAttribute(key)\n                    }\n                    return \n                }\n\n                //EVENTS\n                if(events[key]){\n                    helper = helper || new NodeHelper(node )\n\n\n                    helper.addUpdate(\"events\", {expression:value, key:key.slice(2) })\n                    // nodeRef.events = nodeRef.events || {}\n                    // nodeRef.events[key.slice(2)] = value\n                    \n                    node.removeAttribute(key)\n                    return \n                }\n\n                //ATTRIBUTES\n                if(value.includes(\"{{\")){\n                    helper = helper || new NodeHelper(node )\n\n                    helper.addUpdate(\"attrs\", {expression:value.trim().slice(2, -2), key,})\n                    // dynamic =  value.trim().slice(2, -2) ||\u00A0false\n\n           \n                }\n                \n            })\n        }\n\n\n        if(node.tagName == \"TEMPLATE\"){\n\n            // const templateRef = document.createElement(\"reactive-template\")\n            const templateRef = document.createComment(\"template\")\n       \n            templateRef.__inTemplate = isTemplate\n            const ref = compiledRefs.get(node)\n            node.replaceWith(templateRef)\n            templateRef.__sId = ref.id\n\n            templateRef.id= ref.id\n\n            registerNodeUpdate(templateRef)\n\n            ref.root = templateRef\n\n\n            // templateRef.setAttribute(\"id\", ref.id)\n    \n             document.body.append(node)\n           \n        }\n\n        return {}\n    \n}\n\nfunction compileHelpers(root){\n\n    let isTemplate = false\n    fastTraverseDOM(root, (node)=>{\n      \n\n         \n\n        if(node.parentNode?.nodeType === 11 || node.textContent ==\"template\" ) isTemplate = node.parentNode\n        if(node.previousSibling?.tagName == \"TEMPLATE\" || node.previousSibling?.textContent ==\"template\") isTemplate = false\n   \n        compileHelper(node , isTemplate) \n        \n    })\n\n\n    return compiledRefs\n\n\n}\n\n\n\n\n      /**\n       * \n       *\n       * Update order from chatgpt\n       \n        Style Updates: Apply layout-affecting styles first (e.g., width, height, display).\n        Class Updates: Modify classes next (especially if they affect styles or layout).\n        Child Modifications: Add, remove, or reorder child nodes.\n        Text Content Updates: Update the text content or innerHTML (after structural changes).\n        Other Attributes: Modify attributes that don\u2019t affect layout (e.g., data-*, aria-*).\n        Event Listeners: Add event listeners last, after the DOM is fully updated.\n       */\n        function runUpdates(ctx){\n        \n\n            let {show, text, loop,attrs } =  NodeUpdater.updaters\n             //update attrs\n     \n             \n             // //show\n             // NodeUpdater.updaters\n     \n             // Object.values(NodeUpdater.updaters).forEach(updater=>{\n             //     updater.runUpdate(ctx)\n             // })\n     \n            //  debugger\n            //  nodeUpdateQueue.forEach(([node])=>{\n                \n            //  })\n             updateQueue(ctx)\n            //  compiledRefs.map.forEach(ref=>{\n            //     if(ref.inTemplate)return\n            //      ref.runNodeUpdates(ref.node, ctx)\n            //  })\n     \n     \n     \n             // show.runUpdate(ctx)\n            \n     \n             // loop.runUpdate(ctx)\n     \n             // attrs.runUpdate(ctx)\n     \n     \n             // text.runUpdate(ctx)\n     \n             //event listeners\n             \n           }\n\n\n/**\n * \n\n\n{\n    childNodes:[\n        Node{\n            childNodes:[\n                 Node{\n                 },\n                 Node{\n                 }\n            ]\n        }\n        NextNode{\n\n        }\n    ]\n}\n\n */\n\n\n//this will create a an stack like this\n\n/**\n * \n * \n * \n */\n\n//generates a stack like  stack = [child1, child2, child3, parent]\n\nfunction fastTraverseDOM(root, processNode) {\n\n\n    const stack = [root];\n    \n\n    while (stack.length > 0) {\n\n        let  node = stack.pop();\n    \n       \n        //is is an element instead of a template\n        if( node.hasAttribute && node.hasAttribute(\"s-loop\") && node.tagName !== \"TEMPLATE\"){\n            // let ref =  document.createTextNode(\"\")\n            const newTemplate = document.createElement(\"template\")\n            // let newTemplate = document.createDocumentFragment()\n\n            newTemplate.setAttribute(\"s-loop\", node.getAttribute(\"s-loop\"))\n\n    \n            //remove s-llop to avoid inifinite loop\n            node.removeAttribute(\"s-loop\")\n            node.after(newTemplate)\n            newTemplate.content.appendChild(node)\n\n\n            node = newTemplate\n\n\n\n        }\n\n\n         //also process template children\n         const childNodes = (node.tagName == \"TEMPLATE\" )? node.content.childNodes:node.childNodes\n\n\n        //set a node id\n         processNode(node );\n\n       \n        // Push child nodes to the stack in reverse order\n        // This ensures we process them in the correct order when popping       \n        for (let i = childNodes.length - 1; i >= 0; i--) {\n\n             stack.push(childNodes[i]);\n        }\n\n\n    \n\n    }\n\n  \n\n}\n\n\n\n\n//converts a string text that contain \"{{some}}\" into multiple text nodes\nfunction fastParse(str) {\n    let result = [];\n    let start = 0;\n    let openBrace = str.indexOf('{{');\n    \n    while (openBrace !== -1) {\n        if (start !== openBrace) {\n            const noExpression= str.slice(start, openBrace)\n            // result.push(document.createTextNode(noExpression));\n            result.push(noExpression);\n        }\n        \n        let closeBrace = str.indexOf('}}', openBrace);\n        if (closeBrace === -1) break;\n        \n        let path = str.slice(openBrace + 2, closeBrace).trim();\n         result.push({path});\n        // result.push(document.createTextNode(path))\n        start = closeBrace + 2;\n        openBrace = str.indexOf('{{', start);\n    }\n    \n    if (start < str.length) {\n        const noExpression= str.slice(start)\n        result.push(noExpression)\n        // result.push(document.createTextNode(noExpression));\n    }\n    \n    return result;\n}\n\n\n\n\n\n\n\nfunction createComponent(template){\n\n    \n\n  customElements.define(\n    \"reactive-template\",\n    class extends HTMLElement {\n    static observedAttributes = [\"id\"];\n      constructor() {\n        super();\n\n        debugger\n        // let template = document.getElementById(\"custom-paragraph\");\n        // let templateContent = template.content;\n  \n        // const shadowRoot = this.attachShadow({ mode: \"open\" });\n        // shadowRoot.appendChild(templateContent.cloneNode(true));\n      }\n      attributeChangedCallback(name, oldValue, newValue) {\n        console.log(`Attribute ${name} has changed.`);\n        if(name == \"id\"){\n            let ref = compiledRefs.idMap.get(newValue)\n            if(!ref) debugger\n            let template = ref.node \n\n            \n            // const shadowRoot = this.attachShadow({ mode: \"open\" });\n            // shadowRoot.appendChild(templateContent.cloneNode(true));\n         \n            this.replaceWith(template.content.cloneNode(true))\n        }\n      }\n    },\n  );\n\n\n\n  }\n\n\n\n  function updateNode(root, ctx){\n\n\n    const stack = [root]\n\n    while(stack.length){\n        const node = stack.pop()\n        const ref = compiledRefs.get(node)\n\n        if(ref){\n\n\n             ref.runNodeUpdates(node, ctx, true)\n        }\n        // const childNodes = (node.tagName == \"TEMPLATE\" )? node.content.childNodes:node.childNodes\n        const childNodes = node.childNodes\n\n        for(let i = childNodes?.length - 1; i >= 0; i--){\n           \n            stack.push(childNodes[i])\n           \n        }\n    }\n  }\n\nfunction parallelTraverse(root, clone, callback){\n\n    let stack = [[root, clone]]\n    while(stack.length){\n        let [node, clone] = stack.pop()\n\n        if(!clone?.childNodes)debugger\n        let children = node.childNodes\n        let cloneChildren = clone.childNodes\n\n        callback(node, clone)\n\n        for(let i = children.length - 1; i >= 0; i--){\n            stack.push([children[i], cloneChildren[i]])\n        }\n    }\n\n}\n\nfunction  cloneDeep(template, callback, ){ \n\n\n    const stack = [[template]]\n    let root \n   while(stack.length){\n        let [node,parent, ] = stack.pop()\n\n        if(!node)debugger\n        const isTemplate = node.tagName == \"TEMPLATE\" \n\n        //do not clone templates\n        const newNode = isTemplate?node: node.cloneNode()\n        const ref = compiledRefs.get(node)\n\n        if(ref) newNode.__sId = ref.id\n\n        if(!root) {\n            root = newNode\n           \n        }\n        \n        if( parent && !parent.__inTemplate && !isTemplate) {\n            parent.appendChild(newNode)\n        }\n       \n     \n        //IF IS A TEMPLATE, PASS the parent of the template as a parent\n        const nodeParent = node.tagName == \"TEMPLATE\"?newNode.parentNode:newNode\n        //get child nodes of the fragment\n        const childNodes = (node.tagName == \"TEMPLATE\" )? node.content.childNodes:node.childNodes\n\n        if(callback) callback(newNode, ref, )\n\n        if(node.textContent == \"template\") {\n            debugger\n            continue\n        }\n        if(isTemplate){\n            debugger\n        };\n        \n\n\n        for(let i = childNodes?.length - 1; i >= 0; i--){\n                       \n            stack.push([childNodes[i], nodeParent])\n           \n        }\n    }\n\n    return root\n\n}\n\n\n\n\n\n\n\n\n      class NodeHelper{\n\n        // directives = false\n        // attrs = false\n        // events = false\n        // textContent = false\n\n        node = false\n        updates = []\n\n\n        constructor(node, updaters = {}){\n\n            const validOptions = [ \"updaters\"]\n\n\n   \n            this.id = `id-${idCounter++}`\n         \n            this.node = node\n\n\n            if(node.inTemplate) this.inTemplate = true\n            else if(node.tagName !== \"TEMPLATE\") {\n\n                registerNodeUpdate(node)\n            }\n            // if(updaters){\n            //     Object.entries(updaters).forEach(([id, updater])=>{\n            //         this.addUpdate(id, updater)\n            //     })\n            // }\n\n            compiledRefs.set(node, this)\n            node.__sCompiled \n            // Object.keys(options).forEach(key => {\n            //     if(validOptions.includes(key)) this[key] = options[key]\n            // });\n\n        }\n        addUpdate(id, config){\n\n            let updater = NodeUpdater.getInstance(id)\n\n            if(!updater){\n                console.warn(`Updater ${id} not found`)\n                return\n            }\n\n\n            const payload =  updater.registerHelper(this, config)\n     \n            this.updates.push({updater, payload})\n        }\n        runNodeUpdates(node, ctx, force){\n    \n            if(!node.__sId) node.__sId = this.id\n            Object.values(this.updates).forEach(update=>{\n               \n                if(force){\n                    update.updater.forceUpdate(node, update.payload ,ctx )\n                }else{\n                   \n                    update.updater.runNodeUpdate(node, update.payload ,ctx, update )\n                }\n            })\n\n        }\n    \n      \n\n\n      }\n\n      /**\n       * IMPORTANT:\n       * \n       Summary of Optimal Update Order:\n        Styles (especially layout-affecting styles like width, height, margin)\n        Classes (if they affect styles or layout)\n        Text Content (textContent or innerHTML)\n        Other Attributes (e.g., data-*, aria-*, non-layout attributes)\n       */\n\n    class NodeUpdater{\n        priority = 10\n\n        static updaters = {}\n        constructor(options){\n            this.constructor.updaters[options.id] = this\n\n            this.updateFunction = options.updateFunction\n\n            let validOptions = [\"getValue\", \"resolveExpression\", \"effect\", \"type\", \"priority\", \"id\"]\n            Object.keys(options).forEach(key => {\n                // if(!validOptions.includes(key)) return\n                      this[key] = options[key]\n \n            });\n        }\n        static getInstance(id){\n           return  this.updaters[id] \n        }\n        type = false // text or attribute or false //with false you handle the \n        init(ctx){\n\n        }\n    \n        \n        updateFunction(){\n\n            console.warn(\"Update function not created for this nodeUpdater\")\n            \n        }\n        \n    \n  \n       \n   \n        nodes = new WeakMap()\n        registerHelper(helper, payload){\n\n            const[exp, debug] = payload.expression.split(\":\")\n            payload.expression = exp\n            payload.debug = debug\n\n            this.registerExpression( exp )\n            // this.nodes.push({node, payload})\n\n            const raw = exp\n            const expression = this.expressions[raw]\n\n            return {...payload, expression, raw, helper}\n        }\n        getNodeObject(node){\n            if(this.nodes.has(node)){\n                return this.nodes.get(node)\n            }\n            const obj = { expressions:{}}\n            this.nodes.set(node, obj)\n            return obj\n        }\n        \n        getUpdatePayload(){\n            return {\n                ctx:this.ctx,\n            }\n        }\n        runUpdate(ctx){\n\n            this.nodes.forEach(({node, payload})=>{\n\n                 this.runNodeUpdate(node, payload, ctx)\n            })\n        }\n\n        effect(){\n            return this.getValue(...arguments)\n        }\n        getValue({expression,} , data){\n            \n            return get(data, expression)\n        }\n      \n        getPropertyTarget(obj, prop){\n\n            while(!obj.hasOwnProperty(prop)){\n                \n               if( obj.hasOwnProperty(prop)) return obj\n               let proto = Object.getPrototypeOf(obj)\n               if(proto) obj = proto\n               else return obj\n            }\n            return obj\n        }\n\n        getValueWithPayload( payload, ctx){\n            \n            let expression = payload.expression || payload\n            const raw = expression\n            expression = this.expressions[expression]\n\n            return this.getValue(payload, ctx.data)\n        }\n\n        expressions = {}\n        registerExpression( expression){\n\n            if(this.expressions[expression] ) return \n            \n            let expressionValue = expression\n            if(this.resolveExpression) expressionValue = this.resolveExpression(expression)\n\n            this.expressions[expression] = expressionValue\n\n        }\n\n        forceUpdate(node, payload, ctx){\n\n            if(node.__inTemplate) {                    \n               return;\n            }\n                     \n           const value = this.getValueWithPayload( payload, ctx)\n                                      \n           this.updateFunction(node, { value} ,payload, ctx)\n\n\n        }\n\n        runNodeUpdate(node, payload, ctx, originalUpdate){\n\n                 if(node.__inTemplate) {                    \n                    return;\n                 }\n                         \n                const value = this.getValueWithPayload( payload, ctx)\n                 \n                //filter by original update object and node to avoid adding new updates\n                let nodeObj =this.getNodeObject(node)\n\n                if(nodeObj.originalUpdate) {\n\n                    return\n                } \n\n                nodeObj.originalUpdate = originalUpdate\n\n\n                //skip the ones that just need one update\n                if(!this.effect)  {\n                    this.updateFunction(node, {value}, payload, ctx)\n                    return\n                }\n                \n                //SAVE update BY ORIGINAL UPDATE\n                const updatesByOriginal = this._effectUpdates = this._effectUpdates || new WeakMap()\n\n            \n                let createEffect = !updatesByOriginal.get(originalUpdate)\n\n                let updates = updatesByOriginal.get(originalUpdate) \n\n                if(!updates){\n                    updates = []\n                    updatesByOriginal.set(originalUpdate, updates)\n                }\n\n\n                // if(node.nodeType == node.TEXT_NODE && raw == \"attrs\") debugger\n\n    \n                updates.push({payload, node, ctx})\n                \n                this.updateFunction(node, {value}, payload, ctx)\n                if(!createEffect) {\n          \n                //    if(raw.includes(\"task,\")) console.log(\"skipping effect\",raw, node)\n                    return \n                }\n  \n\n                if(payload.expression.includes(\",\"))debugger\n        \n                if(!this.effect)debugger\n   \n                     watch( \n                        //    this.effect({expression, data:ctx.data})\n                             ()=>{\n                             \n                                return this.getValueWithPayload( payload, ctx)\n                             }\n                            //  ()=>this.updateFunction(node, {value}, payload, ctx)\n                        \n                        , (updatePayload)=>{\n                                      \n                         \n                            const updates = updatesByOriginal.get(originalUpdate)\n                            \n                            //IMPORTANT: updates only sould be larger than one  for loops\n                            //so basically this is a loop feature and I can check index\n                            //to skip other updates\n                            //run mulitple updates of the same nodeHelper update with the same effect\n                            updates.forEach(({node, payload, ctx}, index)=>{\n                              \n                                // if(updates.length > 1 && index != updatePayload.key) return\n                                const value = this.getValueWithPayload( payload, ctx)\n                                                       \n                                if(payload.debug) debugger\n\n                                this.updateFunction(node, {...updatePayload, value} ,payload, ctx)\n                            })\n                            \n                    },{deep:this.deep ?? true, updater:this})\n          \n\n                   \n            \n\n        }\n\n      }\n\n\n\n      const textUpdater = new NodeUpdater({\n\n            priority:3,\n            id:\"text\",\n            updateFunction(node , { value}, {expression, debug}, ctx){\n\n                if(debug)debugger\n                if(node.dataset && node.dataset.la )debugger\n                // value = get(ctx.data, expression)\n                if(value && value.attrs) debugger\n                if(typeof value == \"object\") value = JSON.stringify(value)\n\n                // if(value?.includes && value.includes(\"{{\")){\n                //     value = value.split(/({{.+?}})/g).reduce((c, v)=>{\n                //         if(!v.includes(\"{{\"))return c+v\n                //         const path = v.slice(2, -2)\n                //         return c + get(ctx.data, path)\n                //     }, \"\")\n                // }\n\n                node.textContent = value\n            }\n      })\n\n      const attrsUpdater = new NodeUpdater({\n            \n            priority:4,\n            id:\"attrs\",\n            updateFunction(node,{value, oldValue}, { key,expression, }, ctx){\n\n       \n                // if(value === oldValue)return\n                if(key == \"onkeypress\")debugger\n                node.setAttribute(key, value)\n                if(key == \"value\"){\n                     node.value = value\n\n                    if(!node.__inputEvent){\n\n                        node.__inputEvent = true\n                        nextTick(()=>{\n                            node.addEventListener(\"input\", (e)=>{\n                                 console.log(ctx.data, expression, e.target.value)\n                                set(ctx.data, expression , e.target.value)  \n                                nextTick(()=>{\n                                    \n                                     node.focus()\n                                })\n                            })\n                        })\n                    }\n                    \n                }\n                \n            }\n      })\n\n\n      const listenerRefs = new Map()\n      const eventsUpdater = new NodeUpdater({\n\n            priority:5,\n            id:\"events\",\n            effect:false,\n            updateFunction(node, { value}, { expression, key, }, ctx){\n\n                nextTick(()=>{\n                    this.setupEvent(node, key, expression,  ctx)\n                })\n                \n            },\n\n      })\n\n      Object.assign(eventsUpdater,{\n        setupEvent(node, event,expression, context){\n\n            let nodeRef = this.nodes.get(node)\n            if(!nodeRef) {\n                nodeRef = {}\n                listenerRefs.set(node, nodeRef)\n            }\n\n            const eventName = event\n            const listening = nodeRef.listening = nodeRef.listening || {}\n            const ctx = context.data\n            if(listening[event]){\n                if(listening[event].includes(node)) return\n                listening[event].push(node)\n        \n               const fn =  nodeRef.eventCallbacks[event] \n                \n                nextTick(()=>{\n                        node.addEventListener(eventName,  (e)=>{\n                            \n                            // console.log(\"evenntntntntnntntnt\", e, eventName)\n                         if( !listeners.includes(node))return \n                        fn.call(ctx, e,  node, ctx)    \n                    })\n                })\n               \n                return \n            }\n            const listeners = listening[event] = listening[event]  ||  []\n        \n            if(nodeRef.listening[event].includes(node) )return \n           \n            nodeRef.listening[event].push(node)\n        \n        \n            const value = expression\n        \n        \n            if(!events[\"on\"+event]) {\n                console.warn(`Event ${event} not found`)\n                return  \n            } \n        \n        \n        \n            const fn = this.getEventFunction(value)\n        \n            nodeRef.eventCallbacks = nodeRef.eventCallbacks || {}\n            nodeRef.eventCallbacks[event] = fn\n           \n            nextTick(()=>{\n    \n                node.addEventListener(eventName,  (e)=>{\n        \n                    // console.log(\"evenntntntntnntntnt\", node, e, eventName)\n                    if( !listeners.includes(node))return \n                   fn.call(ctx, e,  node, ctx )    \n               })\n            })\n        \n        \n        },\n        getEventFunction(value){\n\n            let isExpression, isAnonymous,  isNamed, isFunction, caller = \"\";\n            if(value.startsWith(\"(\")) isAnonymous = true\n            if(value.match(/^[a-zA-Z]/)) isNamed = true\n             if(!value.includes(\"(\")) caller = \"(event, node)\"\n        \n             let args = \"\"\n           \n            let stringFn = `this.${value}${caller}`\n            \n           if(isAnonymous){\n        \n                args = value.match(/\\{.+\\(([^)]+)\\)/)?.[1] || \"\"\n            \n                stringFn =`(${value})(event)`\n            }\n           \n            if(isNamed){\n                args = value.match(/\\(([^)]+)\\)/)?.[1] ||\u00A0\"\"\n            }\n        \n        \n            const code =  `\n            \n                let {${args}} = this\n        \n                ${stringFn}   \n            `\n            const  fn = new Function(\"event\",  \"node\", \"ctx\", \"window\" , code )\n        \n            return fn\n        \n        }\n      })\n\n\n\n      //directive updaters\n      Object.entries(directives).forEach(([key, value])=>{\n\n            new NodeUpdater({id:key, ...value})\n      })\n\n  \n\n      \n\n\n      function toRaw(obj){\n        if(typeof obj != \"object\") return obj\n\n        return obj.__raw || obj\n\n      }\n\n\n\n  \n\n      function compare(source, target) {\n        const toAdd = [];\n        const toRemove = [];\n        const toReposition = [];\n        const toKeep = [];\n        const types = new Set(); // Store unique types of values\n        const jobs = new Set();\n      \n        const isArray = Array.isArray(source) && Array.isArray(target);\n      \n        if (isArray) {\n          // Step 1: Create a map for fast lookups in the target array\n          const targetMap = new Map();\n          target.forEach((value, index) => targetMap.set(value, index));\n      \n          // Step 2: Compare source array with the target array\n          for (let i = 0; i < source.length; i++) {\n            const sourceValue = source[i];\n            types.add(typeof sourceValue);  // Track unique types\n      \n            const targetIndex = targetMap.get(sourceValue);\n      \n            if (targetIndex !== undefined) {\n              // Element found in the target array\n              if (i === targetIndex) {\n                // Same position -> toKeep\n                toKeep.push([i, sourceValue]);\n                jobs.add(\"keep\")\n              } else {\n                // Different position -> toReposition\n                toReposition.push([i, sourceValue, targetIndex, target[targetIndex]]);\n                jobs.add(\"move\")\n              }\n              // Remove it from the targetMap to track unvisited elements\n              targetMap.delete(sourceValue);\n            } else {\n              // Element not found in the target array -> toAdd\n              toAdd.push([i, sourceValue]);\n              jobs.add(\"add\")\n            }\n          }\n      \n          // Step 3: Remaining elements in the targetMap are toRemove (index, value)\n          targetMap.forEach(( index, value) => {\n            types.add(typeof value); // Track unique types\n\n            if(typeof index ==\"object\")debugger\n            toRemove.push([index, value]);  // Correct order: [index, value]\n            jobs.add(\"remove\")\n          });\n      \n        } else {\n          // Comparing objects key by key\n          const sourceKeys = Object.keys(source);\n          const targetKeys = Object.keys(target);\n      \n          // Create a Set for fast lookup in target keys\n          const targetKeySet = new Set(targetKeys);\n      \n          // Step 1: Compare source object keys with target\n          sourceKeys.forEach((key) => {\n            types.add(typeof source[key]);  // Track unique types for source\n      \n            if (target.hasOwnProperty(key)) {\n              if (source[key] === target[key]) {\n                // Same value -> toKeep\n                toKeep.push([key, source[key]]);\n                jobs.add(\"keep\")\n              } else {\n                // Different value -> toReposition\n                toReposition.push([key, source[key], key, target[key]]);\n                jobs.add(\"move\")\n              }\n              targetKeySet.delete(key);  // Mark key as visited\n            } else {\n              // Key exists in source but not in target -> toAdd\n              toAdd.push([key, source[key]]);\n              jobs.add(\"add\")\n            }\n          });\n      \n          // Step 2: Remaining keys in targetKeySet -> toRemove (key, value)\n          targetKeySet.forEach((key) => {\n            types.add(typeof target[key]); // Track unique types for target\n            toRemove.push([key, target[key]]);  // Correct order: [key, value]\n            jobs.add(\"remove\")\n          });\n        }\n      \n        return {\n            jobs: Array.from(jobs),\n          toAdd,\n          toRemove,\n          toReposition,\n          toKeep,\n          types: Array.from(types)  // Return unique types as an array\n        };\n      }\n      \n  function parallelUpdate(template, newNode, ctx){\n\n    parallelTraverse(template, newNode, (node, clone)=>{\n\n        let ref = compiledRefs.get(node)\n        if(!newNode)debugger\n    \n        if(ref){\n\n            ref.runNodeUpdates(clone, ctx)\n        }\n    \n      })\n  }\n\n\n  function check(root){\n\n    const stack = [root]\n    const nodes = []\n    while(stack.length){\n        const node = stack.pop()\n\n        const childNodes = node.tagName == \"TEMPLATE\"?node.content.childNodes: node.childNodes\n\n        if(!node.__inTemplate)nodes.push(node)\n        for(let i = childNodes?.length - 1; i >= 0; i--){\n           \n            stack.push(childNodes[i])\n           \n        }\n    }\n\n    return nodes\n\n  }\n\n"],
  "mappings": "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",
  "names": ["prefix", "events", "directives", "node", "oldValue", "value", "key", "args", "ref", "expression", "data", "loopKey", "loopIndex", "path", "get", "obj", "ctx", "target", "prop", "v", "set", "update", "helper", "type", "updateId", "items", "createFragment", "holders", "oldFragment", "holder", "template", "nodeObj", "last", "comparison", "compare", "jobs", "loopNodes", "newUpdate", "inLoop", "afterUpdate", "item", "index", "newObj", "oldKey", "updateNode", "childCtx", "newNode", "child", "i", "parallelUpdate", "fn", "updateQueue", "createContext", "reactive", "watch", "nextTick", "root", "getPrevious", "compiled", "compileHelpers", "runUpdates", "proxies", "isProxyFlag", "isReactive", "interceptors", "reciever", "callbacks", "parent", "origin", "current", "handler", "ReactiveHandler", "proxy", "effectStack", "_ReactiveHandler", "options", "effect", "depth", "deep", "observingProps", "parents", "payload", "deepEffect", "deepEffects", "Effect", "toRaw", "currentEffect", "Manager", "effect", "callback", "options", "Effect", "_Effect", "target", "toRaw", "handler", "ReactiveHandler", "source", "props", "prop", "value", "payload", "isReactive", "reactiveHandler", "observing", "watch", "runOrOption", "t", "set", "obj", "path", "keys", "lastKey", "key", "Manager", "_Manager", "queue", "nextTick", "getCache", "get", "val", "getPrevious", "CompiledRef", "v", "attr", "k", "ref", "id", "compiledRefs", "idCounter", "nodeUpdateQueue", "registerNodeUpdate", "template", "node", "ctx", "runningQueue", "updateQueue", "cloneOrCtx", "childCtx", "parallelUpdate", "compiledRefs", "compileHelper", "isTemplate", "nodeRef", "setNode", "children", "fastParse", "child", "NodeHelper", "helper", "attrs", "attr", "value", "key", "prefix", "directiveKey", "directives", "events", "templateRef", "ref", "compileHelpers", "root", "fastTraverseDOM", "runUpdates", "show", "text", "loop", "NodeUpdater", "processNode", "stack", "newTemplate", "childNodes", "str", "result", "start", "openBrace", "noExpression", "closeBrace", "path", "updateNode", "root", "ctx", "stack", "node", "ref", "compiledRefs", "childNodes", "i", "parallelTraverse", "clone", "callback", "children", "cloneChildren", "NodeHelper", "node", "updaters", "validOptions", "idCounter", "registerNodeUpdate", "compiledRefs", "id", "config", "updater", "NodeUpdater", "payload", "ctx", "force", "update", "options", "key", "helper", "exp", "debug", "raw", "expression", "obj", "data", "get", "prop", "proto", "expressionValue", "value", "originalUpdate", "nodeObj", "updatesByOriginal", "createEffect", "updates", "watch", "updatePayload", "index", "textUpdater", "attrsUpdater", "oldValue", "nextTick", "e", "set", "listenerRefs", "eventsUpdater", "event", "context", "nodeRef", "eventName", "listening", "fn", "listeners", "events", "isExpression", "isAnonymous", "isNamed", "isFunction", "caller", "args", "stringFn", "code", "directives", "toRaw", "compare", "source", "target", "toAdd", "toRemove", "toReposition", "toKeep", "types", "jobs", "targetMap", "i", "sourceValue", "targetIndex", "sourceKeys", "targetKeys", "targetKeySet", "parallelUpdate", "template", "newNode", "parallelTraverse", "clone", "ref"]
}
